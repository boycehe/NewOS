     1                                           ;代码清单，视频配套
     2                                  
     3                                           ;以下常量定义部分。内核的大部分内容都应当固定 
     4                                           flat_4gb_code_seg_sel  equ  0x0008      ;平坦模型下的4GB代码段选择子
     5                                           flat_4gb_data_seg_sel  equ  0x0018      ;平坦模型下的4GB数据段选择子
     6                                  
     7                                           idt_linear_address    equ  0x8001F000   ;中断描述符表的线性地址
     8                                           core_lin_alloc_at     equ  0x80100000   ;内核中可用于分配的起始线性地址
     9                                           core_lin_tcb_addr     equ  0x8001f800   ;内核任务TCB的高端线性地址
    10                                  
    11                                  ;-------------------------------------------------------------------------------
    12                                           ;以下是系统核心的头部，用于加载核心程序 
    13                                  SECTION header vstart=0x80040000
    14                                  
    15 00000000 [00000000]                       core_length      dd core_end       ;核心程序总长度#00
    16                                  
    17 00000004 [19030000]                       core_entry       dd start          ;核心代码段入口点#04
    18                                  
    19                                  ;===============================================================================
    20                                           [bits 32]
    21                                  ;===============================================================================
    22                                  SECTION sys_routine vfollows=header          ;系统公共例程代码段
    23                                  ;-------------------------------------------------------------------------------
    24                                           ;字符串显示例程（适用于平坦内存模型）
    25                                  put_string:                                 ;显示0终止的字符串并移动光标
    26                                                                              ;输入：EBX=字符串的线性地址
    27                                  
    28 00000000 53                               push ebx
    29 00000001 51                               push ecx
    30                                  
    31 00000002 FA                               cli                                ;硬件操作期间，关中断
    32                                  
    33                                    .getc:
    34 00000003 8A0B                             mov cl,[ebx]
    35 00000005 08C9                             or cl,cl                           ;检测串结束标志（0）
    36 00000007 7408                             jz .exit                           ;显示完毕，返回
    37 00000009 E807000000                       call put_char
    38 0000000E 43                               inc ebx
    39 0000000F EBF2                             jmp .getc
    40                                  
    41                                    .exit:
    42                                  
    43 00000011 FB                               sti                                ;硬件操作完毕，开放中断
    44                                  
    45 00000012 59                               pop ecx
    46 00000013 5B                               pop ebx
    47                                  
    48 00000014 CB                               retf                               ;段间返回
    49                                  
    50                                  ;-------------------------------------------------------------------------------
    51                                  put_char:                                   ;在当前光标处显示一个字符,并推进
    52                                                                              ;光标。仅用于段内调用
    53                                                                              ;输入：CL=字符ASCII码
    54 00000015 60                               pushad
    55                                  
    56                                           ;以下取当前光标位置
    57 00000016 66BAD403                         mov dx,0x3d4
    58 0000001A B00E                             mov al,0x0e
    59 0000001C EE                               out dx,al
    60 0000001D 6642                             inc dx                             ;0x3d5
    61 0000001F EC                               in al,dx                           ;高字
    62 00000020 88C4                             mov ah,al
    63                                  
    64 00000022 664A                             dec dx                             ;0x3d4
    65 00000024 B00F                             mov al,0x0f
    66 00000026 EE                               out dx,al
    67 00000027 6642                             inc dx                             ;0x3d5
    68 00000029 EC                               in al,dx                           ;低字
    69 0000002A 6689C3                           mov bx,ax                          ;BX=代表光标位置的16位数
    70 0000002D 81E3FFFF0000                     and ebx,0x0000ffff                 ;准备使用32位寻址方式访问显存
    71                                  
    72 00000033 80F90D                           cmp cl,0x0d                        ;回车符？
    73 00000036 750E                             jnz .put_0a
    74 00000038 6689D8                           mov ax,bx
    75 0000003B B350                             mov bl,80
    76 0000003D F6F3                             div bl
    77 0000003F F6E3                             mul bl
    78 00000041 6689C3                           mov bx,ax
    79 00000044 EB52                             jmp .set_cursor
    80                                  
    81                                    .put_0a:
    82 00000046 80F90A                           cmp cl,0x0a                        ;换行符？
    83 00000049 7506                             jnz .put_other
    84 0000004B 6683C350                         add bx,80
    85 0000004F EB0E                             jmp .roll_screen
    86                                  
    87                                    .put_other:                               ;正常显示字符
    88 00000051 66D1E3                           shl bx,1
    89 00000054 888B00800B80                     mov [0x800b8000+ebx],cl
    90                                  
    91                                           ;以下将光标位置推进一个字符
    92 0000005A 66D1EB                           shr bx,1
    93 0000005D 6643                             inc bx
    94                                  
    95                                    .roll_screen:
    96 0000005F 6681FBD007                       cmp bx,2000                        ;光标超出屏幕？滚屏
    97 00000064 7C32                             jl .set_cursor
    98                                  
    99 00000066 6653                             push bx                            ;为了修改原书程序的逻辑问题，新增
   100                                  
   101 00000068 FC                               cld
   102 00000069 BEA0800B80                       mov esi,0x800b80a0                 ;小心！32位模式下movsb/w/d
   103 0000006E BF00800B80                       mov edi,0x800b8000                 ;使用的是esi/edi/ecx
   104 00000073 B980070000                       mov ecx,1920
   105 00000078 F3A5                             rep movsd
   106 0000007A 66BB000F                         mov bx,3840                        ;清除屏幕最底一行
   107 0000007E B950000000                       mov ecx,80                         ;32位程序应该使用ECX
   108                                    .cls:
   109 00000083 66C78300800B802007               mov word[0x800b8000+ebx],0x0720
   110 0000008C 6683C302                         add bx,2
   111 00000090 E2F1                             loop .cls
   112                                  
   113                                           ;mov bx,1920                       ;为了修改原书程序的逻辑问题，删除
   114 00000092 665B                             pop bx                             ;为了修改原书程序的逻辑问题，新增
   115 00000094 6683EB50                         sub bx,80                          ;为了修改原书程序的逻辑问题，新增
   116                                  
   117                                    .set_cursor:
   118 00000098 66BAD403                         mov dx,0x3d4
   119 0000009C B00E                             mov al,0x0e
   120 0000009E EE                               out dx,al
   121 0000009F 6642                             inc dx                             ;0x3d5
   122 000000A1 88F8                             mov al,bh
   123 000000A3 EE                               out dx,al
   124 000000A4 664A                             dec dx                             ;0x3d4
   125 000000A6 B00F                             mov al,0x0f
   126 000000A8 EE                               out dx,al
   127 000000A9 6642                             inc dx                             ;0x3d5
   128 000000AB 88D8                             mov al,bl
   129 000000AD EE                               out dx,al
   130                                  
   131 000000AE 61                               popad
   132 000000AF C3                               ret
   133                                  
   134                                  ;-------------------------------------------------------------------------------
   135                                  read_hard_disk_0:                           ;从硬盘读取一个逻辑扇区（平坦模型）
   136                                                                              ;EAX=逻辑扇区号
   137                                                                              ;EBX=目标缓冲区线性地址
   138                                                                              ;返回：EBX=EBX+512
   139 000000B0 FA                               cli
   140                                  
   141 000000B1 50                               push eax
   142 000000B2 51                               push ecx
   143 000000B3 52                               push edx
   144                                  
   145 000000B4 50                               push eax
   146                                  
   147 000000B5 66BAF201                         mov dx,0x1f2
   148 000000B9 B001                             mov al,1
   149 000000BB EE                               out dx,al                          ;读取的扇区数
   150                                  
   151 000000BC 6642                             inc dx                             ;0x1f3
   152 000000BE 58                               pop eax
   153 000000BF EE                               out dx,al                          ;LBA地址7~0
   154                                  
   155 000000C0 6642                             inc dx                             ;0x1f4
   156 000000C2 B108                             mov cl,8
   157 000000C4 D3E8                             shr eax,cl
   158 000000C6 EE                               out dx,al                          ;LBA地址15~8
   159                                  
   160 000000C7 6642                             inc dx                             ;0x1f5
   161 000000C9 D3E8                             shr eax,cl
   162 000000CB EE                               out dx,al                          ;LBA地址23~16
   163                                  
   164 000000CC 6642                             inc dx                             ;0x1f6
   165 000000CE D3E8                             shr eax,cl
   166 000000D0 0CE0                             or al,0xe0                         ;第一硬盘  LBA地址27~24
   167 000000D2 EE                               out dx,al
   168                                  
   169 000000D3 6642                             inc dx                             ;0x1f7
   170 000000D5 B020                             mov al,0x20                        ;读命令
   171 000000D7 EE                               out dx,al
   172                                  
   173                                    .waits:
   174 000000D8 EC                               in al,dx
   175 000000D9 2488                             and al,0x88
   176 000000DB 3C08                             cmp al,0x08
   177 000000DD 75F9                             jnz .waits                         ;不忙，且硬盘已准备好数据传输
   178                                  
   179 000000DF B900010000                       mov ecx,256                        ;总共要读取的字数
   180 000000E4 66BAF001                         mov dx,0x1f0
   181                                    .readw:
   182 000000E8 66ED                             in ax,dx
   183 000000EA 668903                           mov [ebx],ax
   184 000000ED 83C302                           add ebx,2
   185 000000F0 E2F6                             loop .readw
   186                                  
   187 000000F2 5A                               pop edx
   188 000000F3 59                               pop ecx
   189 000000F4 58                               pop eax
   190                                  
   191 000000F5 FB                               sti
   192                                  
   193 000000F6 CB                               retf                               ;远返回
   194                                  
   195                                  ;-------------------------------------------------------------------------------
   196                                  ;汇编语言程序是极难一次成功，而且调试非常困难。这个例程可以提供帮助
   197                                  put_hex_dword:                              ;在当前光标处以十六进制形式显示
   198                                                                              ;一个双字并推进光标
   199                                                                              ;输入：EDX=要转换并显示的数字
   200                                                                              ;输出：无
   201 000000F7 60                               pushad
   202                                  
   203 000000F8 BB[A3070000]                     mov ebx,bin_hex                    ;指向核心地址空间内的转换表
   204 000000FD B908000000                       mov ecx,8
   205                                    .xlt:
   206 00000102 C1C204                           rol edx,4
   207 00000105 89D0                             mov eax,edx
   208 00000107 83E00F                           and eax,0x0000000f
   209 0000010A D7                               xlat
   210                                  
   211 0000010B 51                               push ecx
   212 0000010C 88C1                             mov cl,al
   213 0000010E E802FFFFFF                       call put_char
   214 00000113 59                               pop ecx
   215                                  
   216 00000114 E2EC                             loop .xlt
   217                                  
   218 00000116 61                               popad
   219 00000117 CB                               retf
   220                                  
   221                                  ;-------------------------------------------------------------------------------
   222                                  set_up_gdt_descriptor:                      ;在GDT内安装一个新的描述符
   223                                                                              ;输入：EDX:EAX=描述符
   224                                                                              ;输出：CX=描述符的选择子
   225 00000118 50                               push eax
   226 00000119 53                               push ebx
   227 0000011A 52                               push edx
   228                                  
   229 0000011B 0F0105[00000000]                 sgdt [pgdt]                        ;取得GDTR的界限和线性地址
   230                                  
   231 00000122 0FB71D[00000000]                 movzx ebx,word [pgdt]              ;GDT界限
   232 00000129 6643                             inc bx                             ;GDT总字节数，也是下一个描述符偏移
   233 0000012B 031D[02000000]                   add ebx,[pgdt+2]                   ;下一个描述符的线性地址
   234                                  
   235 00000131 8903                             mov [ebx],eax
   236 00000133 895304                           mov [ebx+4],edx
   237                                  
   238 00000136 668305[00000000]08               add word [pgdt],8                  ;增加一个描述符的大小
   239                                  
   240 0000013E 0F0115[00000000]                 lgdt [pgdt]                        ;对GDT的更改生效
   241                                  
   242 00000145 66A1[00000000]                   mov ax,[pgdt]                      ;得到GDT界限值
   243 0000014B 6631D2                           xor dx,dx
   244 0000014E 66BB0800                         mov bx,8
   245 00000152 66F7F3                           div bx                             ;除以8，去掉余数
   246 00000155 6689C1                           mov cx,ax
   247 00000158 66C1E103                         shl cx,3                           ;将索引号移到正确位置
   248                                  
   249 0000015C 5A                               pop edx
   250 0000015D 5B                               pop ebx
   251 0000015E 58                               pop eax
   252                                  
   253 0000015F CB                               retf
   254                                  ;-------------------------------------------------------------------------------
   255                                  make_seg_descriptor:                        ;构造存储器和系统的段描述符
   256                                                                              ;输入：EAX=线性基地址
   257                                                                              ;      EBX=段界限
   258                                                                              ;      ECX=属性。各属性位都在原始
   259                                                                              ;          位置，无关的位清零
   260                                                                              ;返回：EDX:EAX=描述符
   261 00000160 89C2                             mov edx,eax
   262 00000162 C1E010                           shl eax,16
   263 00000165 6609D8                           or ax,bx                           ;描述符前32位(EAX)构造完毕
   264                                  
   265 00000168 81E20000FFFF                     and edx,0xffff0000                 ;清除基地址中无关的位
   266 0000016E C1C208                           rol edx,8
   267 00000171 0FCA                             bswap edx                          ;装配基址的31~24和23~16  (80486+)
   268                                  
   269 00000173 6631DB                           xor bx,bx
   270 00000176 09DA                             or edx,ebx                         ;装配段界限的高4位
   271                                  
   272 00000178 09CA                             or edx,ecx                         ;装配属性
   273                                  
   274 0000017A CB                               retf
   275                                  
   276                                  ;-------------------------------------------------------------------------------
   277                                  make_gate_descriptor:                       ;构造门的描述符（调用门等）
   278                                                                              ;输入：EAX=门代码在段内偏移地址
   279                                                                              ;       BX=门代码所在段的选择子
   280                                                                              ;       CX=段类型及属性等（各属
   281                                                                              ;          性位都在原始位置）
   282                                                                              ;返回：EDX:EAX=完整的描述符
   283 0000017B 53                               push ebx
   284 0000017C 51                               push ecx
   285                                  
   286 0000017D 89C2                             mov edx,eax
   287 0000017F 81E20000FFFF                     and edx,0xffff0000                 ;得到偏移地址高16位
   288 00000185 6609CA                           or dx,cx                           ;组装属性部分到EDX
   289                                  
   290 00000188 25FFFF0000                       and eax,0x0000ffff                 ;得到偏移地址低16位
   291 0000018D C1E310                           shl ebx,16
   292 00000190 09D8                             or eax,ebx                         ;组装段选择子部分
   293                                  
   294 00000192 59                               pop ecx
   295 00000193 5B                               pop ebx
   296                                  
   297 00000194 CB                               retf
   298                                  
   299                                  ;-------------------------------------------------------------------------------
   300                                  allocate_a_4k_page:                         ;分配一个4KB的页
   301                                                                              ;输入：无
   302                                                                              ;输出：EAX=页的物理地址
   303 00000195 53                               push ebx
   304 00000196 51                               push ecx
   305 00000197 52                               push edx
   306                                  
   307 00000198 31C0                             xor eax,eax
   308                                    .b1:
   309 0000019A 0FAB05[0C000000]                 bts [page_bit_map],eax
   310 000001A1 7315                             jnc .b2
   311 000001A3 40                               inc eax
   312 000001A4 3D00020000                       cmp eax,page_map_len*8
   313 000001A9 7CEF                             jl .b1
   314                                  
   315 000001AB BB[61070000]                     mov ebx,message_3
   316 000001B0 9A[00000000]0800                 call flat_4gb_code_seg_sel:put_string
   317 000001B7 F4                               hlt                                ;没有可以分配的页，停机
   318                                  
   319                                    .b2:
   320 000001B8 C1E00C                           shl eax,12                         ;乘以4096（0x1000）
   321                                  
   322 000001BB 5A                               pop edx
   323 000001BC 59                               pop ecx
   324 000001BD 5B                               pop ebx
   325                                  
   326 000001BE C3                               ret
   327                                  
   328                                  ;-------------------------------------------------------------------------------
   329                                  alloc_inst_a_page:                          ;分配一个页，并安装在当前活动的
   330                                                                              ;层级分页结构中
   331                                                                              ;输入：EBX=页的线性地址
   332 000001BF 50                               push eax
   333 000001C0 53                               push ebx
   334 000001C1 51                               push ecx
   335 000001C2 56                               push esi
   336                                  
   337                                           ;检查该线性地址所对应的页表是否存在
   338 000001C3 89DE                             mov esi,ebx
   339 000001C5 81E60000C0FF                     and esi,0xffc00000                 ;清除页表索引和页内偏移部分
   340 000001CB C1EE14                           shr esi,20                         ;将页目录索引乘以4作为页内偏移
   341 000001CE 81CE00F0FFFF                     or esi,0xfffff000                  ;页目录自身的线性地址+表内偏移
   342                                  
   343 000001D4 F70601000000                     test dword [esi],0x00000001        ;P位是否为“1”。检查该线性地址是
   344 000001DA 7529                             jnz .b1                            ;否已经有对应的页表
   345                                  
   346                                           ;创建并安装该线性地址所对应的页表
   347 000001DC E8B4FFFFFF                       call allocate_a_4k_page            ;分配一个页做为页表
   348 000001E1 83C807                           or eax,0x00000007
   349 000001E4 8906                             mov [esi],eax                      ;在页目录中登记该页表
   350                                  
   351                                           ;清空当前页表
   352 000001E6 89D8                             mov eax,ebx
   353 000001E8 250000C0FF                       and eax,0xffc00000
   354 000001ED C1E80A                           shr eax,10
   355 000001F0 0D0000C0FF                       or eax,0xffc00000
   356 000001F5 B900040000                       mov ecx,1024
   357                                    .cls0:
   358 000001FA C70000000000                     mov dword [eax],0x00000000
   359 00000200 83C004                           add eax,4
   360 00000203 E2F5                             loop .cls0
   361                                  
   362                                    .b1:
   363                                           ;检查该线性地址对应的页表项（页）是否存在
   364 00000205 89DE                             mov esi,ebx
   365 00000207 81E600F0FFFF                     and esi,0xfffff000                 ;清除页内偏移部分
   366 0000020D C1EE0A                           shr esi,10                         ;将页目录索引变成页表索引，页表索引乘以4作为页内偏移
   367 00000210 81CE0000C0FF                     or esi,0xffc00000                  ;得到该线性地址对应的页表项
   368                                  
   369 00000216 F70601000000                     test dword [esi],0x00000001        ;P位是否为“1”。检查该线性地址是
   370 0000021C 750A                             jnz .b2                            ;否已经有对应的页
   371                                  
   372                                           ;创建并安装该线性地址所对应的页
   373 0000021E E872FFFFFF                       call allocate_a_4k_page            ;分配一个页，这才是要安装的页
   374 00000223 83C807                           or eax,0x00000007
   375 00000226 8906                             mov [esi],eax
   376                                  
   377                                    .b2:
   378 00000228 5E                               pop esi
   379 00000229 59                               pop ecx
   380 0000022A 5B                               pop ebx
   381 0000022B 58                               pop eax
   382                                  
   383 0000022C CB                               retf
   384                                  
   385                                  ;-------------------------------------------------------------------------------
   386                                  create_copy_cur_pdir:                       ;创建新页目录，并复制当前页目录内容
   387                                                                              ;输入：无
   388                                                                              ;输出：EAX=新页目录的物理地址
   389 0000022D 56                               push esi
   390 0000022E 57                               push edi
   391 0000022F 53                               push ebx
   392 00000230 51                               push ecx
   393                                  
   394 00000231 E85FFFFFFF                       call allocate_a_4k_page
   395 00000236 89C3                             mov ebx,eax
   396 00000238 83CB07                           or ebx,0x00000007
   397 0000023B 891DF8FFFFFF                     mov [0xfffffff8],ebx
   398                                  
   399 00000241 0F013DF8FFFFFF                   invlpg [0xfffffff8]
   400                                  
   401 00000248 BE00F0FFFF                       mov esi,0xfffff000                 ;ESI->当前页目录的线性地址
   402 0000024D BF00E0FFFF                       mov edi,0xffffe000                 ;EDI->新页目录的线性地址
   403 00000252 B900040000                       mov ecx,1024                       ;ECX=要复制的目录项数
   404 00000257 FC                               cld
   405 00000258 F3A5                             repe movsd
   406                                  
   407 0000025A 59                               pop ecx
   408 0000025B 5B                               pop ebx
   409 0000025C 5F                               pop edi
   410 0000025D 5E                               pop esi
   411                                  
   412 0000025E CB                               retf
   413                                  
   414                                  ;-------------------------------------------------------------------------------
   415                                  task_alloc_memory:                          ;在指定任务的虚拟内存空间中分配内存
   416                                                                              ;输入：EBX=任务控制块TCB的线性地址
   417                                                                              ;      ECX=希望分配的字节数
   418                                                                              ;输出：ECX=已分配的起始线性地址
   419 0000025F 50                               push eax
   420                                  
   421 00000260 53                               push ebx                           ;to A
   422                                  
   423                                           ;获得本次内存分配的起始线性地址
   424 00000261 8B5B06                           mov ebx,[ebx+0x06]                 ;获得本次分配的起始线性地址
   425 00000264 89D8                             mov eax,ebx
   426 00000266 01D9                             add ecx,ebx                        ;本次分配，最后一个字节之后的线性地址
   427                                  
   428 00000268 51                               push ecx                           ;To B
   429                                  
   430                                           ;为请求的内存分配页
   431 00000269 81E300F0FFFF                     and ebx,0xfffff000
   432 0000026F 81E100F0FFFF                     and ecx,0xfffff000
   433                                    .next:
   434 00000275 9A[BF010000]0800                 call flat_4gb_code_seg_sel:alloc_inst_a_page
   435                                                                              ;安装当前线性地址所在的页
   436 0000027C 81C300100000                     add ebx,0x1000                     ;+4096
   437 00000282 39CB                             cmp ebx,ecx
   438 00000284 7EEF                             jle .next
   439                                  
   440                                           ;将用于下一次分配的线性地址强制按4字节对齐
   441 00000286 59                               pop ecx                            ;B
   442                                  
   443 00000287 F7C103000000                     test ecx,0x00000003                ;线性地址是4字节对齐的吗？
   444 0000028D 7406                             jz .algn                           ;是，直接返回
   445 0000028F 83C104                           add ecx,4                          ;否，强制按4字节对齐
   446 00000292 83E1FC                           and ecx,0xfffffffc
   447                                  
   448                                    .algn:
   449 00000295 5B                               pop ebx                            ;A
   450                                  
   451 00000296 894B06                           mov [ebx+0x06],ecx                 ;将下次分配可用的线性地址回存到TCB中
   452 00000299 89C1                             mov ecx,eax
   453                                  
   454 0000029B 58                               pop eax
   455                                  
   456 0000029C CB                               retf
   457                                  
   458                                  ;-------------------------------------------------------------------------------
   459                                  allocate_memory:                            ;在当前任务的地址空间中分配内存
   460                                                                              ;输入：ECX=希望分配的字节数
   461                                                                              ;输出：ECX=起始线性地址 
   462 0000029D 50                               push eax
   463 0000029E 53                               push ebx
   464                                  
   465                                           ;得到TCB链表首节点的线性地址
   466 0000029F A1[B30F0000]                     mov eax,[tcb_chain]                ;EAX=首节点的线性地址
   467                                  
   468                                           ;搜索状态为忙（当前任务）的节点
   469                                    .s0:
   470 000002A4 66837804FF                       cmp word [eax+0x04],0xffff
   471 000002A9 7404                             jz .s1                             ;找到忙的节点，EAX=节点的线性地址
   472 000002AB 8B00                             mov eax,[eax]
   473 000002AD EBF5                             jmp .s0
   474                                  
   475                                           ;开始分配内存
   476                                    .s1:
   477 000002AF 89C3                             mov ebx,eax
   478 000002B1 9A[5F020000]0800                 call flat_4gb_code_seg_sel:task_alloc_memory
   479                                  
   480 000002B8 5B                               pop ebx
   481 000002B9 58                               pop eax
   482                                  
   483 000002BA CB                               retf
   484                                  
   485                                  ;-------------------------------------------------------------------------------
   486                                  initiate_task_switch:                       ;主动发起任务切换
   487                                                                              ;输入：无
   488                                                                              ;输出：无。
   489 000002BB 60                               pushad
   490                                  
   491 000002BC A1[B30F0000]                     mov eax,[tcb_chain]
   492 000002C1 83F800                           cmp eax,0
   493 000002C4 7445                             jz .return
   494                                  
   495                                           ;搜索状态为忙（当前任务）的节点
   496                                    .b0:
   497 000002C6 66837804FF                       cmp word [eax+0x04],0xffff
   498 000002CB 0F44F0                           cmove esi,eax                     ;找到忙的节点，ESI=节点的线性地址
   499 000002CE 7404                             jz .b1
   500 000002D0 8B00                             mov eax,[eax]
   501 000002D2 EBF2                             jmp .b0
   502                                  
   503                                           ;从当前节点继续搜索就绪任务的节点
   504                                    .b1:
   505 000002D4 8B18                             mov ebx,[eax]
   506 000002D6 09DB                             or ebx,ebx
   507 000002D8 740E                             jz .b2                            ;到链表尾部也未发现就绪节点，从头找
   508 000002DA 66837B0400                       cmp word [ebx+0x04],0x0000
   509 000002DF 0F44FB                           cmove edi,ebx                     ;已找到就绪节点，EDI=节点的线性地址
   510 000002E2 741C                             jz .b3
   511 000002E4 89D8                             mov eax,ebx
   512 000002E6 EBEC                             jmp .b1
   513                                  
   514                                    .b2:
   515 000002E8 8B1D[B30F0000]                   mov ebx,[tcb_chain]               ;EBX=链表首节点线性地址
   516                                    .b20:
   517 000002EE 66837B0400                       cmp word [ebx+0x04],0x0000
   518 000002F3 0F44FB                           cmove edi,ebx                     ;已找到就绪节点，EDI=节点的线性地址
   519 000002F6 7408                             jz .b3
   520 000002F8 8B1B                             mov ebx,[ebx]
   521 000002FA 09DB                             or ebx,ebx
   522 000002FC 740D                             jz .return                        ;链表中已经不存在就绪任务，返回
   523 000002FE EBEE                             jmp .b20
   524                                  
   525                                           ;就绪任务的节点已经找到，准备切换到该任务
   526                                    .b3:
   527 00000300 66F75604                         not word [esi+0x04]               ;将忙状态的节点改为就绪状态的节点
   528 00000304 66F75704                         not word [edi+0x04]               ;将就绪状态的节点改为忙状态的节点
   529 00000308 FF6F14                           jmp far [edi+0x14]                ;任务切换
   530                                  
   531                                    .return:
   532 0000030B 61                               popad
   533                                  
   534 0000030C CB                               retf
   535                                  
   536                                  ;-------------------------------------------------------------------------------
   537                                  terminate_current_task:                     ;终止当前任务
   538                                                                              ;注意，执行此例程时，当前任务仍在
   539                                                                              ;运行中。此例程其实也是当前任务的
   540                                                                              ;一部分 
   541 0000030D 26A1[B30F0000]                   mov eax,[es:tcb_chain]
   542                                                                              ;EAX=首节点的线性地址
   543                                           ;搜索状态为忙（当前任务）的节点
   544                                    .s0:
   545 00000313 66837804FF                       cmp word [eax+0x04],0xffff
   546 00000318 7404                             jz .s1                             ;找到忙的节点，EAX=节点的线性地址
   547 0000031A 8B00                             mov eax,[eax]
   548 0000031C EBF5                             jmp .s0
   549                                  
   550                                           ;将状态为忙的节点改成终止状态
   551                                    .s1:
   552 0000031E 66C740043333                     mov word [eax+0x04],0x3333
   553                                  
   554                                           ;搜索就绪状态的任务
   555 00000324 268B1D[B30F0000]                 mov ebx,[es:tcb_chain]            ;EBX=链表首节点线性地址
   556                                    .s2:
   557 0000032B 66837B0400                       cmp word [ebx+0x04],0x0000
   558 00000330 7404                             jz .s3                            ;已找到就绪节点，EBX=节点的线性地址
   559 00000332 8B1B                             mov ebx,[ebx]
   560 00000334 EBF5                             jmp .s2
   561                                  
   562                                           ;就绪任务的节点已经找到，准备切换到该任务
   563                                    .s3:
   564 00000336 66F75304                         not word [ebx+0x04]               ;将就绪状态的节点改为忙状态的节点
   565 0000033A FF6B14                           jmp far [ebx+0x14]                ;任务切换
   566                                  
   567                                  ;-------------------------------------------------------------------------------
   568                                  general_interrupt_handler:                  ;通用的中断处理过程
   569 0000033D 50                               push eax
   570                                  
   571 0000033E B020                             mov al,0x20                        ;中断结束命令EOI
   572 00000340 E6A0                             out 0xa0,al                        ;向从片发送
   573 00000342 E620                             out 0x20,al                        ;向主片发送
   574                                  
   575 00000344 58                               pop eax
   576                                  
   577 00000345 CF                               iretd
   578                                  
   579                                  ;-------------------------------------------------------------------------------
   580                                  general_exception_handler:                  ;通用的异常处理过程
   581 00000346 BB[7F070000]                     mov ebx,excep_msg
   582 0000034B 9A[00000000]0800                 call flat_4gb_code_seg_sel:put_string
   583                                  
   584 00000352 FA                               cli
   585                                  
   586 00000353 F4                               hlt
   587                                  
   588                                  ;-------------------------------------------------------------------------------
   589                                  rtm_0x70_interrupt_handle:                  ;实时时钟中断处理过程
   590                                  
   591 00000354 60                               pushad
   592                                  
   593 00000355 B020                             mov al,0x20                        ;中断结束命令EOI
   594 00000357 E6A0                             out 0xa0,al                        ;向8259A从片发送
   595 00000359 E620                             out 0x20,al                        ;向8259A主片发送
   596                                  
   597 0000035B B00C                             mov al,0x0c                        ;寄存器C的索引。且开放NMI
   598 0000035D E670                             out 0x70,al
   599 0000035F E471                             in al,0x71                         ;读一下RTC的寄存器C，否则只发生一次中断
   600                                                                              ;此处不考虑闹钟和周期性中断的情况
   601                                           ;请求任务调度
   602 00000361 9A[BB020000]0800                 call flat_4gb_code_seg_sel:initiate_task_switch
   603                                  
   604 00000368 61                               popad
   605                                  
   606 00000369 CF                               iretd
   607                                  
   608                                  ;-------------------------------------------------------------------------------
   609                                  do_task_clean:                             ;清理已经终止的任务并回收资源
   610                                  
   611                                           ;搜索TCB链表，找到状态为终止的节点
   612                                           ;将节点从链表中拆除
   613                                           ;回收任务占用的各种资源（可以从它的TCB中找到）
   614                                  
   615 0000036A CB                               retf
   616                                  
   617                                  sys_routine_end:
   618                                  
   619                                  ;===============================================================================
   620                                  SECTION core_data vfollows=sys_routine       ;系统核心的数据段
   621                                  ;------------------------------------------------------------------------------- 
   622 00000000 0000                             pgdt             dw  0             ;用于设置和修改GDT 
   623 00000002 00000000                                          dd  0
   624                                  
   625 00000006 0000                             pidt             dw  0
   626 00000008 00000000                                          dd  0
   627                                  
   628 0000000C FFFFFFFFFFFF5555                 page_bit_map     db  0xff,0xff,0xff,0xff,0xff,0xff,0x55,0x55
   629 00000014 FFFFFFFFFFFFFFFF                                  db  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
   630 0000001C FFFFFFFFFFFFFFFF                                  db  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
   631 00000024 FFFFFFFFFFFFFFFF                                  db  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
   632 0000002C 5555555555555555                                  db  0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55
   633 00000034 0000000000000000                                  db  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   634 0000003C 0000000000000000                                  db  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   635 00000044 0000000000000000                                  db  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   636                                           page_map_len     equ $-page_bit_map
   637                                  
   638                                           ;符号地址检索表
   639                                           salt:
   640 0000004C 405072696E74537472-              salt_1           db  '@PrintString'
   640 00000055 696E67             
   641 00000058 00<rep F4h>                                  times 256-($-salt_1) db 0
   642 0000014C [00000000]                                        dd  put_string
   643 00000150 0800                                              dw  flat_4gb_code_seg_sel
   644                                  
   645 00000152 40526561644469736B-              salt_2           db  '@ReadDiskData'
   645 0000015B 44617461           
   646 0000015F 00<rep F3h>                                  times 256-($-salt_2) db 0
   647 00000252 [B0000000]                                        dd  read_hard_disk_0
   648 00000256 0800                                              dw  flat_4gb_code_seg_sel
   649                                  
   650 00000258 405072696E7444776F-              salt_3           db  '@PrintDwordAsHexString'
   650 00000261 726441734865785374-
   650 0000026A 72696E67           
   651 0000026E 00<rep EAh>                                  times 256-($-salt_3) db 0
   652 00000358 [F7000000]                                        dd  put_hex_dword
   653 0000035C 0800                                              dw  flat_4gb_code_seg_sel
   654                                  
   655 0000035E 405465726D696E6174-              salt_4           db  '@TerminateProgram'
   655 00000367 6550726F6772616D   
   656 0000036F 00<rep EFh>                                  times 256-($-salt_4) db 0
   657 0000045E [0D030000]                                        dd  terminate_current_task
   658 00000462 0800                                              dw  flat_4gb_code_seg_sel
   659                                  
   660 00000464 40496E69745461736B-              salt_5           db  '@InitTaskSwitch'
   660 0000046D 537769746368       
   661 00000473 00<rep F1h>                                  times 256-($-salt_5) db 0
   662 00000564 [BB020000]                                        dd  initiate_task_switch
   663 00000568 0800                                              dw  flat_4gb_code_seg_sel
   664                                  
   665 0000056A 406D616C6C6F63                   salt_6           db  '@malloc'
   666 00000571 00<rep F9h>                                  times 256-($-salt_6) db 0
   667 0000066A [9D020000]                                        dd  allocate_memory
   668 0000066E 0800                                              dw  flat_4gb_code_seg_sel
   669                                  
   670                                           salt_item_len   equ $-salt_6
   671                                           salt_items      equ ($-salt)/salt_item_len
   672                                  
   673 00000670 202053797374656D20-              message_0        db  '  System core is runing in protect mode,'
   673 00000679 636F72652069732072-
   673 00000682 756E696E6720696E20-
   673 0000068B 70726F74656374206D-
   673 00000694 6F64652C           
   674 00000698 494454206973206D6F-                               db  'IDT is mounted.',0x0d,0x0a,0
   674 000006A1 756E7465642E0D0A00 
   675                                  
   676 000006AA 0D0A202000                       cpu_brnd0        db  0x0d,0x0a,'  ',0
   677 000006AF 00<rep 34h>                      cpu_brand  times 52  db 0
   678 000006E3 0D0A0D0A00                       cpu_brnd1        db  0x0d,0x0a,0x0d,0x0a,0
   679                                  
   680 000006E8 2020506167696E6720-              message_1        db  '  Paging is enabled.System core is mapped to'
   680 000006F1 697320656E61626C65-
   680 000006FA 642E53797374656D20-
   680 00000703 636F7265206973206D-
   680 0000070C 617070656420746F   
   681 00000714 206C696E6561722061-                               db  ' linear address 0x80000000.',0x0d,0x0a,0
   681 0000071D 646472657373203078-
   681 00000726 38303030303030302E-
   681 0000072F 0D0A00             
   682                                  
   683 00000732 202053797374656D20-              message_2        db  '  System wide CALL-GATE mounted and test OK.'
   683 0000073B 776964652043414C4C-
   683 00000744 2D47415445206D6F75-
   683 0000074D 6E74656420616E6420-
   683 00000756 74657374204F4B2E   
   684 0000075E 0D0A00                                            db  0x0d,0x0a,0
   685                                  
   686 00000761 2A2A2A2A2A2A2A2A4E-              message_3        db  '********No more pages********',0
   686 0000076A 6F206D6F7265207061-
   686 00000773 6765732A2A2A2A2A2A-
   686 0000077C 2A2A00             
   687                                  
   688 0000077F 2A2A2A2A2A2A2A2A45-              excep_msg        db  '********Exception encounted********',0
   688 00000788 7863657074696F6E20-
   688 00000791 656E636F756E746564-
   688 0000079A 2A2A2A2A2A2A2A2A00 
   689                                  
   690 000007A3 303132333435363738-              bin_hex          db '0123456789ABCDEF'
   690 000007AC 39414243444546     
   691                                                                              ;put_hex_dword子过程用的查找表 
   692                                  
   693 000007B3 00<rep 800h>                     core_buf   times 2048 db 0         ;内核用的缓冲区
   694                                  
   695                                           ;任务控制块链
   696 00000FB3 00000000                         tcb_chain        dd  0
   697                                  
   698 00000FB7 2020436F7265207461-              core_msg1        db  '  Core task created.',0x0d,0x0a,0
   698 00000FC0 736B20637265617465-
   698 00000FC9 642E0D0A00         
   699                                                   
   700 00000FCE 5B434F524520544153-              core_msg2        db  '[CORE TASK]: I am working!',0x0d,0x0a,0
   700 00000FD7 4B5D3A204920616D20-
   700 00000FE0 776F726B696E67210D-
   700 00000FE9 0A00               
   701                                  
   702                                  core_data_end:
   703                                                 
   704                                  ;===============================================================================
   705                                  SECTION core_code vfollows=core_data
   706                                  ;-------------------------------------------------------------------------------
   707                                  fill_descriptor_in_ldt:                     ;在LDT内安装一个新的描述符
   708                                                                              ;输入：EDX:EAX=描述符
   709                                                                              ;          EBX=TCB基地址
   710                                                                              ;输出：CX=描述符的选择子
   711 00000000 50                               push eax
   712 00000001 52                               push edx
   713 00000002 57                               push edi
   714                                  
   715 00000003 8B7B0C                           mov edi,[ebx+0x0c]                 ;获得LDT基地址
   716                                           
   717 00000006 31C9                             xor ecx,ecx
   718 00000008 668B4B0A                         mov cx,[ebx+0x0a]                  ;获得LDT界限
   719 0000000C 6641                             inc cx                             ;LDT的总字节数，即新描述符偏移地址
   720                                           
   721 0000000E 89040F                           mov [edi+ecx+0x00],eax
   722 00000011 89540F04                         mov [edi+ecx+0x04],edx             ;安装描述符
   723                                  
   724 00000015 6683C108                         add cx,8                           
   725 00000019 6649                             dec cx                             ;得到新的LDT界限值 
   726                                  
   727 0000001B 66894B0A                         mov [ebx+0x0a],cx                  ;更新LDT界限值到TCB
   728                                  
   729 0000001F 6689C8                           mov ax,cx
   730 00000022 6631D2                           xor dx,dx
   731 00000025 66B90800                         mov cx,8
   732 00000029 66F7F1                           div cx
   733                                           
   734 0000002C 6689C1                           mov cx,ax
   735 0000002F 66C1E103                         shl cx,3                           ;左移3位，并且
   736 00000033 6683C904                         or cx,0000_0000_0000_0100B         ;使TI位=1，指向LDT，最后使RPL=00 
   737                                  
   738 00000037 5F                               pop edi
   739 00000038 5A                               pop edx
   740 00000039 58                               pop eax
   741                                       
   742 0000003A C3                               ret
   743                                           
   744                                  ;------------------------------------------------------------------------------- 
   745                                  load_relocate_program:                      ;加载并重定位用户程序
   746                                                                              ;输入: PUSH 逻辑扇区号
   747                                                                              ;      PUSH 任务控制块基地址
   748                                                                              ;输出：无 
   749 0000003B 60                               pushad
   750                                        
   751 0000003C 89E5                             mov ebp,esp                        ;为访问通过堆栈传递的参数做准备
   752                                        
   753                                           ;清空当前页目录的前半部分（对应低2GB的局部地址空间）
   754 0000003E BB00F0FFFF                       mov ebx,0xfffff000
   755 00000043 31F6                             xor esi,esi
   756                                    .clsp:
   757 00000045 C704B300000000                   mov dword [ebx+esi*4],0x00000000
   758 0000004C 46                               inc esi
   759 0000004D 81FE00020000                     cmp esi,512
   760 00000053 7CF0                             jl .clsp
   761                                  
   762 00000055 0F20DB                           mov ebx,cr3                        ;刷新TLB
   763 00000058 0F22DB                           mov cr3,ebx
   764                                  
   765                                           ;以下开始加载用户程序
   766 0000005B 8B4528                           mov eax,[ebp+10*4]                 ;从堆栈中取出用户程序起始扇区号
   767 0000005E BB[B3070000]                     mov ebx,core_buf                   ;读取程序头部数据
   768 00000063 9A[B0000000]0800                 call flat_4gb_code_seg_sel:read_hard_disk_0
   769                                  
   770                                           ;以下判断整个程序有多大
   771 0000006A A1[B3070000]                     mov eax,[core_buf]                 ;程序尺寸
   772 0000006F 89C3                             mov ebx,eax
   773 00000071 81E300FEFFFF                     and ebx,0xfffffe00                 ;使之512字节对齐（能被512整除的数低
   774 00000077 81C300020000                     add ebx,512                        ;9位都为0
   775 0000007D A9FF010000                       test eax,0x000001ff                ;程序的大小正好是512的倍数吗?
   776 00000082 0F45C3                           cmovnz eax,ebx                     ;不是。使用凑整的结果
   777                                  
   778 00000085 8B7524                           mov esi,[ebp+9*4]                  ;从堆栈中取得TCB的基地址
   779                                  
   780 00000088 89C1                             mov ecx,eax                        ;实际需要申请的内存数量
   781 0000008A 89F3                             mov ebx,esi
   782 0000008C 9A[5F020000]0800                 call flat_4gb_code_seg_sel:task_alloc_memory
   783                                  
   784 00000093 89CB                             mov ebx,ecx                        ;ebx -> 申请到的内存首地址 == 0
   785 00000095 31D2                             xor edx,edx
   786 00000097 B900020000                       mov ecx,512
   787 0000009C F7F1                             div ecx
   788 0000009E 89C1                             mov ecx,eax                        ;总扇区数
   789                                  
   790 000000A0 8B4528                           mov eax,[ebp+10*4]                 ;起始扇区号
   791                                    .b1:
   792 000000A3 9A[B0000000]0800                 call flat_4gb_code_seg_sel:read_hard_disk_0
   793 000000AA 40                               inc eax
   794 000000AB E2F6                             loop .b1                           ;循环读，直到读完整个用户程序
   795                                  
   796                                           ;以下创建用户任务的TSS
   797 000000AD B968000000                       mov ecx,104                        ;tss的基本尺寸
   798 000000B2 66894E12                         mov [esi+0x12],cx
   799 000000B6 66FF4E12                         dec word [esi+0x12]                ;登记TSS界限值到TCB
   800 000000BA 9A[9D020000]0800                 call flat_4gb_code_seg_sel:allocate_memory
   801 000000C1 894E14                           mov [esi+0x14],ecx                 ;登记TSS的线性基地址到TCB
   802                                  
   803                                           ;以下申请创建LDT所需要的内存
   804 000000C4 89F3                             mov ebx,esi
   805 000000C6 B9A0000000                       mov ecx,160                        ;允许安装20个LDT描述符
   806 000000CB 9A[5F020000]0800                 call flat_4gb_code_seg_sel:task_alloc_memory
   807 000000D2 894E0C                           mov [esi+0x0c],ecx                 ;登记LDT的线性基地址到TCB中
   808 000000D5 66C7460AFFFF                     mov word [esi+0x0a],0xffff         ;登记LDT初始的界限到TCB中
   809                                  
   810                                  
   811                                           ;建立用户任务代码段描述符
   812 000000DB B800000000                       mov eax,0x00000000
   813 000000E0 BBFFFF0F00                       mov ebx,0x000fffff
   814 000000E5 B900F8C000                       mov ecx,0x00c0f800                 ;4KB粒度的代码段描述符，特权级3
   815 000000EA 9A[60010000]0800                 call flat_4gb_code_seg_sel:make_seg_descriptor
   816 000000F1 89F3                             mov ebx,esi                        ;TCB的基地址
   817 000000F3 E808FFFFFF                       call fill_descriptor_in_ldt
   818 000000F8 6683C903                         or cx,0000_0000_0000_0011B         ;设置选择子的特权级为3
   819                                  
   820 000000FC 8B5E14                           mov ebx,[esi+0x14]                 ;从TCB中获取TSS的线性地址
   821 000000FF 66894B4C                         mov [ebx+76],cx                    ;填写TSS的CS域
   822                                  
   823                                           ;建立用户任务数据段描述符
   824 00000103 B800000000                       mov eax,0x00000000
   825 00000108 BBFFFF0F00                       mov ebx,0x000fffff
   826 0000010D B900F2C000                       mov ecx,0x00c0f200                 ;4KB粒度的数据段描述符，特权级3
   827 00000112 9A[60010000]0800                 call flat_4gb_code_seg_sel:make_seg_descriptor
   828 00000119 89F3                             mov ebx,esi                        ;TCB的基地址
   829 0000011B E8E0FEFFFF                       call fill_descriptor_in_ldt
   830 00000120 6683C903                         or cx,0000_0000_0000_0011B         ;设置选择子的特权级为3
   831                                  
   832 00000124 8B5E14                           mov ebx,[esi+0x14]                 ;从TCB中获取TSS的线性地址
   833 00000127 66894B54                         mov [ebx+84],cx                    ;填写TSS的DS域
   834 0000012B 66894B48                         mov [ebx+72],cx                    ;填写TSS的ES域
   835 0000012F 66894B58                         mov [ebx+88],cx                    ;填写TSS的FS域
   836 00000133 66894B5C                         mov [ebx+92],cx                    ;填写TSS的GS域
   837                                  
   838                                           ;为用户任务栈段分配空间
   839 00000137 89F3                             mov ebx,esi
   840 00000139 B900100000                       mov ecx,4096                       ;4KB的空间
   841 0000013E 9A[5F020000]0800                 call flat_4gb_code_seg_sel:task_alloc_memory
   842                                  
   843                                           ;建立用户任务栈段描述符
   844 00000145 B800000000                       mov eax,0x00000000
   845 0000014A BBFFFF0F00                       mov ebx,0x000fffff
   846 0000014F B900F2C000                       mov ecx,0x00c0f200                 ;4KB粒度的数据段描述符，特权级3
   847 00000154 9A[60010000]0800                 call flat_4gb_code_seg_sel:make_seg_descriptor
   848 0000015B 89F3                             mov ebx,esi                        ;TCB的基地址
   849 0000015D E89EFEFFFF                       call fill_descriptor_in_ldt
   850 00000162 6683C903                         or cx,0000_0000_0000_0011B         ;设置选择子的特权级为3
   851                                  
   852 00000166 8B5E14                           mov ebx,[esi+0x14]                 ;从TCB中获取TSS的线性地址
   853 00000169 66894B50                         mov [ebx+80],cx                    ;填写TSS的SS域
   854 0000016D 8B5606                           mov edx,[esi+0x06]                 ;堆栈的高端线性地址=下一可分配地址
   855 00000170 895338                           mov [ebx+56],edx                   ;填写TSS的ESP域
   856                                  
   857                                           ;重定位SALT 
   858 00000173 FC                               cld
   859                                  
   860 00000174 8B0D0C000000                     mov ecx,[0x0c]                     ;U-SALT条目数(通过访问4GB段取得)
   861 0000017A 8B3D08000000                     mov edi,[0x08]                     ;U-SALT在4GB段内的偏移
   862                                    .b2: 
   863 00000180 51                               push ecx
   864 00000181 57                               push edi
   865                                        
   866 00000182 B906000000                       mov ecx,salt_items
   867 00000187 BE[4C000000]                     mov esi,salt
   868                                    .b3:
   869 0000018C 57                               push edi
   870 0000018D 56                               push esi
   871 0000018E 51                               push ecx
   872                                  
   873 0000018F B940000000                       mov ecx,64                         ;检索表中，每条目的比较次数 
   874 00000194 F3A7                             repe cmpsd                         ;每次比较4字节 
   875 00000196 7519                             jnz .b4
   876 00000198 8B06                             mov eax,[esi]                      ;若匹配，则esi恰好指向其后的地址
   877 0000019A 26898700FFFFFF                   mov [es:edi-256],eax               ;将字符串改写成偏移地址 
   878 000001A1 668B4604                         mov ax,[esi+4]
   879 000001A5 6683C803                         or ax,0000000000000011B            ;以用户程序自己的特权级使用调用门
   880                                                                              ;故RPL=3 
   881 000001A9 2666898704FFFFFF                 mov [es:edi-252],ax                ;回填调用门选择子 
   882                                    .b4:
   883                                        
   884 000001B1 59                               pop ecx
   885 000001B2 5E                               pop esi
   886 000001B3 81C606010000                     add esi,salt_item_len
   887 000001B9 5F                               pop edi                            ;从头比较 
   888 000001BA E2D0                             loop .b3
   889                                        
   890 000001BC 5F                               pop edi
   891 000001BD 81C700010000                     add edi,256
   892 000001C3 59                               pop ecx
   893 000001C4 E2BA                             loop .b2
   894                                  
   895 000001C6 8B7524                           mov esi,[ebp+9*4]                 ;从堆栈中取得TCB的基地址
   896                                  
   897                                           ;在用户任务的局部地址空间内创建0特权级堆栈
   898 000001C9 89F3                             mov ebx,esi
   899 000001CB B900100000                       mov ecx,4096                       ;4KB的空间
   900 000001D0 9A[5F020000]0800                 call flat_4gb_code_seg_sel:task_alloc_memory
   901                                  
   902 000001D7 B800000000                       mov eax,0x00000000
   903 000001DC BBFFFF0F00                       mov ebx,0x000fffff
   904 000001E1 B90092C000                       mov ecx,0x00c09200                 ;4KB粒度的堆栈段描述符，特权级0
   905 000001E6 9A[60010000]0800                 call flat_4gb_code_seg_sel:make_seg_descriptor
   906 000001ED 89F3                             mov ebx,esi                        ;TCB的基地址
   907 000001EF E80CFEFFFF                       call fill_descriptor_in_ldt
   908 000001F4 6683C900                         or cx,0000_0000_0000_0000B         ;设置选择子的特权级为0
   909                                  
   910 000001F8 8B5E14                           mov ebx,[esi+0x14]                 ;从TCB中获取TSS的线性地址
   911 000001FB 66894B08                         mov [ebx+8],cx                     ;填写TSS的SS0域
   912 000001FF 8B5606                           mov edx,[esi+0x06]                 ;堆栈的高端线性地址
   913 00000202 895304                           mov [ebx+4],edx                    ;填写TSS的ESP0域
   914                                  
   915                                           ;在用户任务的局部地址空间内创建1特权级堆栈
   916 00000205 89F3                             mov ebx,esi
   917 00000207 B900100000                       mov ecx,4096                       ;4KB的空间
   918 0000020C 9A[5F020000]0800                 call flat_4gb_code_seg_sel:task_alloc_memory
   919                                  
   920 00000213 B800000000                       mov eax,0x00000000
   921 00000218 BBFFFF0F00                       mov ebx,0x000fffff
   922 0000021D B900B2C000                       mov ecx,0x00c0b200                 ;4KB粒度，读写，特权级1
   923 00000222 9A[60010000]0800                 call flat_4gb_code_seg_sel:make_seg_descriptor
   924 00000229 89F3                             mov ebx,esi                        ;TCB的基地址
   925 0000022B E8D0FDFFFF                       call fill_descriptor_in_ldt
   926 00000230 6683C901                         or cx,0000_0000_0000_0001          ;设置选择子的特权级为1
   927                                  
   928 00000234 8B5E14                           mov ebx,[esi+0x14]                 ;从TCB中获取TSS的线性地址
   929 00000237 66894B10                         mov [ebx+16],cx                    ;填写TSS的SS1域
   930 0000023B 8B5606                           mov edx,[esi+0x06]                 ;堆栈的高端线性地址
   931 0000023E 89530C                           mov [ebx+12],edx                   ;填写TSS的ESP1域
   932                                  
   933                                           ;在用户任务的局部地址空间内创建2特权级堆栈
   934 00000241 89F3                             mov ebx,esi
   935 00000243 B900100000                       mov ecx,4096                       ;4KB的空间
   936 00000248 9A[5F020000]0800                 call flat_4gb_code_seg_sel:task_alloc_memory
   937                                  
   938 0000024F B800000000                       mov eax,0x00000000
   939 00000254 BBFFFF0F00                       mov ebx,0x000fffff
   940 00000259 B900D2C000                       mov ecx,0x00c0d200                 ;4KB粒度，读写，特权级2
   941 0000025E 9A[60010000]0800                 call flat_4gb_code_seg_sel:make_seg_descriptor
   942 00000265 89F3                             mov ebx,esi                        ;TCB的基地址
   943 00000267 E894FDFFFF                       call fill_descriptor_in_ldt
   944 0000026C 6683C90A                         or cx,0000_0000_0000_0010          ;设置选择子的特权级为2
   945                                  
   946 00000270 8B5E14                           mov ebx,[esi+0x14]                 ;从TCB中获取TSS的线性地址
   947 00000273 66894B18                         mov [ebx+24],cx                    ;填写TSS的SS2域
   948 00000277 8B5606                           mov edx,[esi+0x06]                 ;堆栈的高端线性地址
   949 0000027A 895314                           mov [ebx+20],edx                   ;填写TSS的ESP2域
   950                                  
   951                                           ;在GDT中登记LDT描述符
   952 0000027D 8B460C                           mov eax,[esi+0x0c]                 ;LDT的起始线性地址
   953 00000280 0FB75E0A                         movzx ebx,word [esi+0x0a]          ;LDT段界限
   954 00000284 B900820000                       mov ecx,0x00008200                 ;LDT描述符，特权级0
   955 00000289 9A[60010000]0800                 call flat_4gb_code_seg_sel:make_seg_descriptor
   956 00000290 9A[18010000]0800                 call flat_4gb_code_seg_sel:set_up_gdt_descriptor
   957 00000297 66894E10                         mov [esi+0x10],cx                  ;登记LDT选择子到TCB中
   958                                         
   959                                  
   960                                           ;登记基本的TSS表格内容
   961 0000029B 8B5E14                           mov ebx,[esi+0x14]                 ;从TCB中获取TSS的线性地址
   962 0000029E 66894B60                         mov [ebx+96],cx                    ;填写TSS的LDT域
   963                                  
   964 000002A2 66C7030000                       mov word [ebx+0],0                 ;反向链=0
   965                                  
   966 000002A7 668B5612                         mov dx,[esi+0x12]                  ;段长度（界限）
   967 000002AB 66895366                         mov [ebx+102],dx                   ;填写TSS的I/O位图偏移域
   968                                  
   969 000002AF 66C743640000                     mov word [ebx+100],0               ;T=0
   970                                  
   971 000002B5 A104000000                       mov eax,[0x04]                     ;从任务的4GB地址空间获取入口点
   972 000002BA 894320                           mov [ebx+32],eax                   ;填写TSS的EIP域
   973                                  
   974 000002BD 9C                               pushfd
   975 000002BE 8F4124                           pop dword [ecx+36]                 ;EFLAGS
   976                                  
   977                                           ;在GDT中登记TSS描述符
   978 000002C1 8B4614                           mov eax,[esi+0x14]                 ;TSS的起始线性地址
   979 000002C4 0FB75E12                         movzx ebx,word [esi+0x12]          ;段长度（界限）
   980 000002C8 B900890000                       mov ecx,0x00008900                 ;TSS描述符，特权级0
   981 000002CD 9A[60010000]0800                 call flat_4gb_code_seg_sel:make_seg_descriptor
   982 000002D4 9A[18010000]0800                 call flat_4gb_code_seg_sel:set_up_gdt_descriptor
   983 000002DB 66894E18                         mov [esi+0x18],cx                  ;登记TSS选择子到TCB
   984                                  
   985                                           ;创建用户任务的页目录
   986                                           ;注意！页的分配和使用是由页位图决定的，可以不占用线性地址空间
   987 000002DF 9A[2D020000]0800                 call flat_4gb_code_seg_sel:create_copy_cur_pdir
   988 000002E6 8B5E14                           mov ebx,[esi+0x14]                 ;从TCB中获取TSS的线性地址
   989 000002E9 89431C                           mov dword [ebx+28],eax             ;填写TSS的CR3(PDBR)域
   990                                  
   991 000002EC 61                               popad
   992                                        
   993 000002ED C20800                           ret 8                              ;丢弃调用本过程前压入的参数 
   994                                        
   995                                  ;-------------------------------------------------------------------------------
   996                                  append_to_tcb_link:                         ;在TCB链上追加任务控制块
   997                                                                              ;输入：ECX=TCB线性基地址
   998 000002F0 50                               push eax
   999 000002F1 52                               push edx
  1000                                  
  1001 000002F2 FA                               cli
  1002                                  
  1003 000002F3 C70100000000                     mov dword [ecx+0x00],0             ;当前TCB指针域清零，以指示这是最
  1004                                                                              ;后一个TCB
  1005                                                                               
  1006 000002F9 A1[B30F0000]                     mov eax,[tcb_chain]                ;TCB表头指针
  1007 000002FE 09C0                             or eax,eax                         ;链表为空？
  1008 00000300 740D                             jz .notcb 
  1009                                           
  1010                                    .searc:
  1011 00000302 89C2                             mov edx,eax
  1012 00000304 8B02                             mov eax,[edx+0x00]
  1013 00000306 09C0                             or eax,eax               
  1014 00000308 75F8                             jnz .searc
  1015                                  
  1016 0000030A 26890A                           mov [es: edx+0x00],ecx
  1017 0000030D EB06                             jmp .retpc
  1018                                           
  1019                                    .notcb:       
  1020 0000030F 890D[B30F0000]                   mov [tcb_chain],ecx                ;若为空表，直接令表头指针指向TCB
  1021                                           
  1022                                    .retpc:
  1023 00000315 FB                               sti
  1024                                  
  1025 00000316 5A                               pop edx
  1026 00000317 58                               pop eax
  1027                                           
  1028 00000318 C3                               ret
  1029                                           
  1030                                  ;-------------------------------------------------------------------------------
  1031                                  start:
  1032                                           ;创建中断描述符表IDT
  1033                                           ;注意！在此期间，不得开放中断，也不得调用put_string例程！
  1034                                  
  1035                                           ;前20个向量是处理器异常使用的
  1036 00000319 B8[46030000]                     mov eax,general_exception_handler  ;门代码在段内偏移地址
  1037 0000031E 66BB0800                         mov bx,flat_4gb_code_seg_sel         ;门代码所在段的选择子
  1038 00000322 66B9008E                         mov cx,0x8e00                      ;32位中断门，0特权级
  1039 00000326 9A[7B010000]0800                 call flat_4gb_code_seg_sel:make_gate_descriptor
  1040                                  
  1041 0000032D BB00F00180                       mov ebx,idt_linear_address         ;中断描述符表的线性地址
  1042 00000332 31F6                             xor esi,esi
  1043                                    .idt0:
  1044 00000334 8904F3                           mov [ebx+esi*8],eax
  1045 00000337 8954F304                         mov [ebx+esi*8+4],edx
  1046 0000033B 46                               inc esi
  1047 0000033C 83FE13                           cmp esi,19                         ;安装前20个异常中断处理过程
  1048 0000033F 7EF3                             jle .idt0
  1049                                  
  1050                                           ;其余为保留或硬件使用的中断向量
  1051 00000341 B8[3D030000]                     mov eax,general_interrupt_handler  ;门代码在段内偏移地址
  1052 00000346 66BB0800                         mov bx,flat_4gb_code_seg_sel       ;门代码所在段的选择子
  1053 0000034A 66B9008E                         mov cx,0x8e00                      ;32位中断门，0特权级
  1054 0000034E 9A[7B010000]0800                 call flat_4gb_code_seg_sel:make_gate_descriptor
  1055                                  
  1056 00000355 BB00F00180                       mov ebx,idt_linear_address         ;中断描述符表的线性地址
  1057                                    .idt1:
  1058 0000035A 8904F3                           mov [ebx+esi*8],eax
  1059 0000035D 8954F304                         mov [ebx+esi*8+4],edx
  1060 00000361 46                               inc esi
  1061 00000362 81FEFF000000                     cmp esi,255                        ;安装普通的中断处理过程
  1062 00000368 7EF0                             jle .idt1
  1063                                  
  1064                                           ;设置实时时钟中断处理过程
  1065 0000036A B8[54030000]                     mov eax,rtm_0x70_interrupt_handle  ;门代码在段内偏移地址
  1066 0000036F 66BB0800                         mov bx,flat_4gb_code_seg_sel       ;门代码所在段的选择子
  1067 00000373 66B9008E                         mov cx,0x8e00                      ;32位中断门，0特权级
  1068 00000377 9A[7B010000]0800                 call flat_4gb_code_seg_sel:make_gate_descriptor
  1069                                  
  1070 0000037E BB00F00180                       mov ebx,idt_linear_address         ;中断描述符表的线性地址
  1071 00000383 898380030000                     mov [ebx+0x70*8],eax
  1072 00000389 899384030000                     mov [ebx+0x70*8+4],edx
  1073                                  
  1074                                           ;准备开放中断
  1075 0000038F 66C705[06000000]FF-              mov word [pidt],256*8-1            ;IDT的界限
  1075 00000397 07                 
  1076 00000398 C705[08000000]00F0-              mov dword [pidt+2],idt_linear_address
  1076 000003A0 0180               
  1077 000003A2 0F011D[06000000]                 lidt [pidt]                        ;加载中断描述符表寄存器IDTR
  1078                                  
  1079                                           ;设置8259A中断控制器
  1080 000003A9 B011                             mov al,0x11
  1081 000003AB E620                             out 0x20,al                        ;ICW1：边沿触发/级联方式
  1082 000003AD B020                             mov al,0x20
  1083 000003AF E621                             out 0x21,al                        ;ICW2:起始中断向量
  1084 000003B1 B004                             mov al,0x04
  1085 000003B3 E621                             out 0x21,al                        ;ICW3:从片级联到IR2
  1086 000003B5 B001                             mov al,0x01
  1087 000003B7 E621                             out 0x21,al                        ;ICW4:非总线缓冲，全嵌套，正常EOI
  1088                                  
  1089 000003B9 B011                             mov al,0x11
  1090 000003BB E6A0                             out 0xa0,al                        ;ICW1：边沿触发/级联方式
  1091 000003BD B070                             mov al,0x70
  1092 000003BF E6A1                             out 0xa1,al                        ;ICW2:起始中断向量
  1093 000003C1 B004                             mov al,0x04
  1094 000003C3 E6A1                             out 0xa1,al                        ;ICW3:从片级联到IR2
  1095 000003C5 B001                             mov al,0x01
  1096 000003C7 E6A1                             out 0xa1,al                        ;ICW4:非总线缓冲，全嵌套，正常EOI
  1097                                  
  1098                                           ;设置和时钟中断相关的硬件
  1099 000003C9 B00B                             mov al,0x0b                        ;RTC寄存器B
  1100 000003CB 0C80                             or al,0x80                         ;阻断NMI
  1101 000003CD E670                             out 0x70,al
  1102 000003CF B012                             mov al,0x12                        ;设置寄存器B，禁止周期性中断，开放更
  1103 000003D1 E671                             out 0x71,al                        ;新结束后中断，BCD码，24小时制
  1104                                  
  1105 000003D3 E4A1                             in al,0xa1                         ;读8259从片的IMR寄存器
  1106 000003D5 24FE                             and al,0xfe                        ;清除bit 0(此位连接RTC)
  1107 000003D7 E6A1                             out 0xa1,al                        ;写回此寄存器
  1108                                  
  1109 000003D9 B00C                             mov al,0x0c
  1110 000003DB E670                             out 0x70,al
  1111 000003DD E471                             in al,0x71                         ;读RTC寄存器C，复位未决的中断状态
  1112                                  
  1113 000003DF FB                               sti                                ;开放硬件中断
  1114                                  
  1115 000003E0 BB[70060000]                     mov ebx,message_0
  1116 000003E5 9A[00000000]0800                 call flat_4gb_code_seg_sel:put_string
  1117                                  
  1118                                           ;显示处理器品牌信息
  1119 000003EC B802000080                       mov eax,0x80000002
  1120 000003F1 0FA2                             cpuid
  1121 000003F3 A3[AF060000]                     mov [cpu_brand + 0x00],eax
  1122 000003F8 891D[B3060000]                   mov [cpu_brand + 0x04],ebx
  1123 000003FE 890D[B7060000]                   mov [cpu_brand + 0x08],ecx
  1124 00000404 8915[BB060000]                   mov [cpu_brand + 0x0c],edx
  1125                                  
  1126 0000040A B803000080                       mov eax,0x80000003
  1127 0000040F 0FA2                             cpuid
  1128 00000411 A3[BF060000]                     mov [cpu_brand + 0x10],eax
  1129 00000416 891D[C3060000]                   mov [cpu_brand + 0x14],ebx
  1130 0000041C 890D[C7060000]                   mov [cpu_brand + 0x18],ecx
  1131 00000422 8915[CB060000]                   mov [cpu_brand + 0x1c],edx
  1132                                  
  1133 00000428 B804000080                       mov eax,0x80000004
  1134 0000042D 0FA2                             cpuid
  1135 0000042F A3[CF060000]                     mov [cpu_brand + 0x20],eax
  1136 00000434 891D[D3060000]                   mov [cpu_brand + 0x24],ebx
  1137 0000043A 890D[D7060000]                   mov [cpu_brand + 0x28],ecx
  1138 00000440 8915[DB060000]                   mov [cpu_brand + 0x2c],edx
  1139                                  
  1140 00000446 BB[AA060000]                     mov ebx,cpu_brnd0                  ;显示处理器品牌信息
  1141 0000044B 9A[00000000]0800                 call flat_4gb_code_seg_sel:put_string
  1142 00000452 BB[AF060000]                     mov ebx,cpu_brand
  1143 00000457 9A[00000000]0800                 call flat_4gb_code_seg_sel:put_string
  1144 0000045E BB[E3060000]                     mov ebx,cpu_brnd1
  1145 00000463 9A[00000000]0800                 call flat_4gb_code_seg_sel:put_string
  1146                                  
  1147                                           ;以下开始安装为整个系统服务的调用门。特权级之间的控制转移必须使用门
  1148 0000046A BF[4C000000]                     mov edi,salt                       ;C-SALT表的起始位置 
  1149 0000046F B906000000                       mov ecx,salt_items                 ;C-SALT表的条目数量 
  1150                                    .g0:
  1151 00000474 51                               push ecx   
  1152 00000475 8B8700010000                     mov eax,[edi+256]                  ;该条目入口点的32位偏移地址 
  1153 0000047B 668B9F04010000                   mov bx,[edi+260]                   ;该条目入口点的段选择子 
  1154 00000482 66B900EC                         mov cx,1_11_0_1100_000_00000B      ;特权级3的调用门(3以上的特权级才
  1155                                                                              ;允许访问)，0个参数(因为用寄存器
  1156                                                                              ;传递参数，而没有用栈) 
  1157 00000486 9A[7B010000]0800                 call flat_4gb_code_seg_sel:make_gate_descriptor
  1158 0000048D 9A[18010000]0800                 call flat_4gb_code_seg_sel:set_up_gdt_descriptor
  1159 00000494 66898F04010000                   mov [edi+260],cx                   ;将返回的门描述符选择子回填
  1160 0000049B 81C706010000                     add edi,salt_item_len              ;指向下一个C-SALT条目 
  1161 000004A1 59                               pop ecx
  1162 000004A2 E2D0                             loop .g0
  1163                                  
  1164                                           ;对门进行测试 
  1165 000004A4 BB[32070000]                     mov ebx,message_2
  1166 000004A9 FF1D[4C010000]                   call far [salt_1+256]              ;通过门显示信息(偏移量将被忽略) 
  1167                                  
  1168                                           ;开始创建和确立内核任务
  1169 000004AF B900F80180                       mov ecx,core_lin_tcb_addr          ;移至高端之后的内核任务TCB线性地址
  1170 000004B4 66C74104FFFF                     mov word [ecx+0x04],0xffff         ;任务的状态为“忙”
  1171 000004BA C7410600001080                   mov dword [ecx+0x06],core_lin_alloc_at
  1172                                                                              ;登记内核中可用于分配的起始线性地址
  1173 000004C1 E82AFEFFFF                       call append_to_tcb_link            ;将内核任务的TCB添加到TCB链中
  1174                                  
  1175 000004C6 89CE                             mov esi,ecx
  1176                                  
  1177                                           ;为内核任务的TSS分配内存空间。所有TSS必须创建在内核空间
  1178 000004C8 B968000000                       mov ecx,104                        ;为该任务的TSS分配内存
  1179 000004CD 9A[9D020000]0800                 call flat_4gb_code_seg_sel:allocate_memory
  1180 000004D4 894E14                           mov [esi+0x14],ecx                 ;在内核TCB中保存TSS基地址
  1181                                  
  1182                                           ;在程序管理器的TSS中设置必要的项目
  1183 000004D7 66C7010000                       mov word [ecx+0],0                 ;反向链=0
  1184 000004DC 0F20D8                           mov eax,cr3
  1185 000004DF 89411C                           mov dword [ecx+28],eax             ;登记CR3(PDBR)
  1186 000004E2 66C741600000                     mov word [ecx+96],0                ;没有LDT。处理器允许没有LDT的任务。
  1187 000004E8 66C741640000                     mov word [ecx+100],0               ;T=0
  1188 000004EE 66C741666700                     mov word [ecx+102],103             ;没有I/O位图。0特权级事实上不需要。
  1189                                                                              ;不需要0、1、2特权级堆栈。0特级不
  1190                                                                              ;会向低特权级转移控制。
  1191                                           
  1192                                           ;创建TSS描述符，并安装到GDT中 
  1193 000004F4 89C8                             mov eax,ecx                        ;TSS的起始线性地址
  1194 000004F6 BB67000000                       mov ebx,103                        ;段长度（界限）
  1195 000004FB B900890000                       mov ecx,0x00008900                 ;TSS描述符，特权级0
  1196 00000500 9A[60010000]0800                 call flat_4gb_code_seg_sel:make_seg_descriptor
  1197 00000507 9A[18010000]0800                 call flat_4gb_code_seg_sel:set_up_gdt_descriptor
  1198 0000050E 66894E18                         mov word [esi+0x18],cx             ;登记TSS选择子到TCB
  1199                                  
  1200                                           ;任务寄存器TR中的内容是任务存在的标志，该内容也决定了当前任务是谁。
  1201                                           ;下面的指令为当前正在执行的0特权级任务“程序管理器”后补手续（TSS）。
  1202 00000512 0F00D9                           ltr cx
  1203                                  
  1204                                           ;现在可认为“程序管理器”任务正执行中
  1205 00000515 BB[B70F0000]                     mov ebx,core_msg1
  1206 0000051A 9A[00000000]0800                 call flat_4gb_code_seg_sel:put_string
  1207                                  
  1208                                           ;以下开始创建用户任务
  1209 00000521 B91A000000                       mov ecx,0x1a
  1210 00000526 9A[9D020000]0800                 call flat_4gb_code_seg_sel:allocate_memory
  1211 0000052D 66C741040000                     mov word [ecx+0x04],0              ;任务状态：就绪
  1212 00000533 C7410600000000                   mov dword [ecx+0x06],0             ;任务内可用于分配的初始线性地址
  1213                                  
  1214 0000053A 6A32                             push dword 50                      ;用户程序位于逻辑50扇区
  1215 0000053C 51                               push ecx                           ;压入任务控制块起始线性地址 
  1216 0000053D E8F9FAFFFF                       call load_relocate_program
  1217 00000542 E8A9FDFFFF                       call append_to_tcb_link            ;将此TCB添加到TCB链中
  1218                                  
  1219                                           ;可以创建更多的任务，例如：
  1220 00000547 B91A000000                       mov ecx,0x1a
  1221 0000054C 9A[9D020000]0800                 call flat_4gb_code_seg_sel:allocate_memory
  1222 00000553 66C741040000                     mov word [ecx+0x04],0              ;任务状态：空闲
  1223 00000559 C7410600000000                   mov dword [ecx+0x06],0             ;任务内可用于分配的初始线性地址
  1224                                  
  1225 00000560 6A64                             push dword 100                     ;用户程序位于逻辑100扇区
  1226 00000562 51                               push ecx                           ;压入任务控制块起始线性地址
  1227                                  
  1228 00000563 E8D3FAFFFF                       call load_relocate_program
  1229 00000568 E883FDFFFF                       call append_to_tcb_link            ;将此TCB添加到TCB链中
  1230                                  
  1231                                    .do_switch:
  1232 0000056D BB[CE0F0000]                     mov ebx,core_msg2
  1233 00000572 9A[00000000]0800                 call flat_4gb_code_seg_sel:put_string
  1234                                  
  1235                                           ;清理已经终止的任务，并回收它们占用的资源
  1236 00000579 9A[6A030000]0800                 call flat_4gb_code_seg_sel:do_task_clean
  1237                                  
  1238 00000580 F4                               hlt
  1239                                  
  1240 00000581 EBEA                             jmp .do_switch
  1241                                  
  1242                                  core_code_end:
  1243                                  
  1244                                  ;-------------------------------------------------------------------------------
  1245                                  SECTION core_trail
  1246                                  ;-------------------------------------------------------------------------------
  1247                                  core_end:
