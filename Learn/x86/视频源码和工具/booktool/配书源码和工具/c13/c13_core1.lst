     1                                           ;文件名：c13_core0.asm
     2                                           ;文件说明：保护模式微型核心程序 
     3                                  
     4                                  ;-------------------------------------------------------------------------------
     5                                           ;以下常量定义部分。内核的大部分内容都应当固定 
     6                                           core_code_seg_sel     equ  0x38    ;内核代码段选择子
     7                                           core_data_seg_sel     equ  0x30    ;内核数据段选择子 
     8                                           sys_routine_seg_sel   equ  0x28    ;系统公共例程代码段的选择子 
     9                                           video_ram_seg_sel     equ  0x20    ;视频显示缓冲区的段选择子
    10                                           core_stack_seg_sel    equ  0x18    ;内核堆栈段选择子
    11                                           mem_0_4_gb_seg_sel    equ  0x08    ;整个0-4GB内存的段的选择子
    12                                  
    13                                  ;-------------------------------------------------------------------------------
    14                                           ;以下是系统核心的头部，用于加载核心程序 
    15 00000000 [00000000]                       core_length      dd core_end       ;核心程序总长度#00
    16                                  
    17 00000004 [00000000]                       sys_routine_seg  dd section.sys_routine.start
    18                                                                              ;系统公用例程段位置#04
    19                                  
    20 00000008 [00000000]                       core_data_seg    dd section.core_data.start
    21                                                                              ;核心数据段位置#08
    22                                  
    23 0000000C [00000000]                       core_code_seg    dd section.core_code.start
    24                                                                              ;核心代码段位置#0c
    25                                  
    26                                  
    27 00000010 [49010000]                       core_entry       dd start          ;核心代码段入口点#10
    28 00000014 3800                                              dw core_code_seg_sel
    29                                  
    30                                  ;===============================================================================
    31                                           [bits 32]
    32                                  ;===============================================================================
    33                                  SECTION sys_routine vstart=0                ;系统公共例程代码段 
    34                                  ;-------------------------------------------------------------------------------
    35                                           ;字符串显示例程
    36                                  put_string:                                 ;显示0终止的字符串并移动光标 
    37                                                                              ;输入：DS:EBX=串地址
    38 00000000 51                               push ecx
    39                                    .getc:
    40 00000001 8A0B                             mov cl,[ebx]
    41 00000003 08C9                             or cl,cl
    42 00000005 7408                             jz .exit
    43 00000007 E805000000                       call put_char
    44 0000000C 43                               inc ebx
    45 0000000D EBF2                             jmp .getc
    46                                  
    47                                    .exit:
    48 0000000F 59                               pop ecx
    49 00000010 CB                               retf                               ;段间返回
    50                                  
    51                                  ;-------------------------------------------------------------------------------
    52                                  put_char:                                   ;在当前光标处显示一个字符,并推进
    53                                                                              ;光标。仅用于段内调用 
    54                                                                              ;输入：CL=字符ASCII码 
    55 00000011 60                               pushad
    56                                  
    57                                           ;以下取当前光标位置
    58 00000012 66BAD403                         mov dx,0x3d4
    59 00000016 B00E                             mov al,0x0e
    60 00000018 EE                               out dx,al
    61 00000019 6642                             inc dx                             ;0x3d5
    62 0000001B EC                               in al,dx                           ;高字
    63 0000001C 88C4                             mov ah,al
    64                                  
    65 0000001E 664A                             dec dx                             ;0x3d4
    66 00000020 B00F                             mov al,0x0f
    67 00000022 EE                               out dx,al
    68 00000023 6642                             inc dx                             ;0x3d5
    69 00000025 EC                               in al,dx                           ;低字
    70 00000026 6689C3                           mov bx,ax                          ;BX=代表光标位置的16位数
    71                                  
    72 00000029 80F90D                           cmp cl,0x0d                        ;回车符？
    73 0000002C 750E                             jnz .put_0a
    74 0000002E 6689D8                           mov ax,bx
    75 00000031 B350                             mov bl,80
    76 00000033 F6F3                             div bl
    77 00000035 F6E3                             mul bl
    78 00000037 6689C3                           mov bx,ax
    79 0000003A EB64                             jmp .set_cursor
    80                                  
    81                                    .put_0a:
    82 0000003C 80F90A                           cmp cl,0x0a                        ;换行符？
    83 0000003F 7506                             jnz .put_other
    84 00000041 6683C350                         add bx,80
    85 00000045 EB15                             jmp .roll_screen
    86                                  
    87                                    .put_other:                               ;正常显示字符
    88 00000047 06                               push es
    89 00000048 B820000000                       mov eax,video_ram_seg_sel          ;0xb8000段的选择子
    90 0000004D 8EC0                             mov es,eax
    91 0000004F 66D1E3                           shl bx,1
    92 00000052 2667880F                         mov [es:bx],cl
    93 00000056 07                               pop es
    94                                  
    95                                           ;以下将光标位置推进一个字符
    96 00000057 66D1EB                           shr bx,1
    97 0000005A 6643                             inc bx
    98                                  
    99                                    .roll_screen:
   100 0000005C 6681FBD007                       cmp bx,2000                        ;光标超出屏幕？滚屏
   101 00000061 7C3D                             jl .set_cursor
   102                                  
   103 00000063 6653                             push bx                            ;为了修改原书程序的逻辑问题，新增
   104 00000065 1E                               push ds
   105 00000066 06                               push es
   106 00000067 B820000000                       mov eax,video_ram_seg_sel
   107 0000006C 8ED8                             mov ds,eax
   108 0000006E 8EC0                             mov es,eax
   109 00000070 FC                               cld
   110 00000071 BEA0000000                       mov esi,0xa0                       ;小心！32位模式下movsb/w/d 
   111 00000076 BF00000000                       mov edi,0x00                       ;使用的是esi/edi/ecx 
   112 0000007B B980070000                       mov ecx,1920
   113 00000080 F3A5                             rep movsd
   114 00000082 66BB000F                         mov bx,3840                        ;清除屏幕最底一行
   115 00000086 B950000000                       mov ecx,80                         ;32位程序应该使用ECX
   116                                    .cls:
   117 0000008B 266667C7072007                   mov word[es:bx],0x0720
   118 00000092 6683C302                         add bx,2
   119 00000096 E2F3                             loop .cls
   120                                  
   121 00000098 07                               pop es
   122 00000099 1F                               pop ds
   123                                  
   124                                           ;mov bx,1920                       ;为了修改原书程序的逻辑问题，删除
   125 0000009A 665B                             pop bx                             ;为了修改原书程序的逻辑问题，新增
   126 0000009C 6683EB50                         sub bx,80                          ;为了修改原书程序的逻辑问题，新增
   127                                  
   128                                    .set_cursor:
   129 000000A0 66BAD403                         mov dx,0x3d4
   130 000000A4 B00E                             mov al,0x0e
   131 000000A6 EE                               out dx,al
   132 000000A7 6642                             inc dx                             ;0x3d5
   133 000000A9 88F8                             mov al,bh
   134 000000AB EE                               out dx,al
   135 000000AC 664A                             dec dx                             ;0x3d4
   136 000000AE B00F                             mov al,0x0f
   137 000000B0 EE                               out dx,al
   138 000000B1 6642                             inc dx                             ;0x3d5
   139 000000B3 88D8                             mov al,bl
   140 000000B5 EE                               out dx,al
   141                                  
   142 000000B6 61                               popad
   143 000000B7 C3                               ret                                
   144                                  
   145                                  ;-------------------------------------------------------------------------------
   146                                  read_hard_disk_0:                           ;从硬盘读取一个逻辑扇区
   147                                                                              ;EAX=逻辑扇区号
   148                                                                              ;DS:EBX=目标缓冲区地址
   149                                                                              ;返回：EBX=EBX+512
   150 000000B8 50                               push eax 
   151 000000B9 51                               push ecx
   152 000000BA 52                               push edx
   153                                        
   154 000000BB 50                               push eax
   155                                           
   156 000000BC 66BAF201                         mov dx,0x1f2
   157 000000C0 B001                             mov al,1
   158 000000C2 EE                               out dx,al                          ;读取的扇区数
   159                                  
   160 000000C3 6642                             inc dx                             ;0x1f3
   161 000000C5 58                               pop eax
   162 000000C6 EE                               out dx,al                          ;LBA地址7~0
   163                                  
   164 000000C7 6642                             inc dx                             ;0x1f4
   165 000000C9 B108                             mov cl,8
   166 000000CB D3E8                             shr eax,cl
   167 000000CD EE                               out dx,al                          ;LBA地址15~8
   168                                  
   169 000000CE 6642                             inc dx                             ;0x1f5
   170 000000D0 D3E8                             shr eax,cl
   171 000000D2 EE                               out dx,al                          ;LBA地址23~16
   172                                  
   173 000000D3 6642                             inc dx                             ;0x1f6
   174 000000D5 D3E8                             shr eax,cl
   175 000000D7 0CE0                             or al,0xe0                         ;第一硬盘  LBA地址27~24
   176 000000D9 EE                               out dx,al
   177                                  
   178 000000DA 6642                             inc dx                             ;0x1f7
   179 000000DC B020                             mov al,0x20                        ;读命令
   180 000000DE EE                               out dx,al
   181                                  
   182                                    .waits:
   183 000000DF EC                               in al,dx
   184 000000E0 2488                             and al,0x88
   185 000000E2 3C08                             cmp al,0x08
   186 000000E4 75F9                             jnz .waits                         ;不忙，且硬盘已准备好数据传输 
   187                                  
   188 000000E6 B900010000                       mov ecx,256                        ;总共要读取的字数
   189 000000EB 66BAF001                         mov dx,0x1f0
   190                                    .readw:
   191 000000EF 66ED                             in ax,dx
   192 000000F1 668903                           mov [ebx],ax
   193 000000F4 83C302                           add ebx,2
   194 000000F7 E2F6                             loop .readw
   195                                  
   196 000000F9 5A                               pop edx
   197 000000FA 59                               pop ecx
   198 000000FB 58                               pop eax
   199                                        
   200 000000FC CB                               retf                               ;段间返回 
   201                                  
   202                                  ;-------------------------------------------------------------------------------
   203                                  ;汇编语言程序是极难一次成功，而且调试非常困难。这个例程可以提供帮助
   204                                  put_hex_dword:                              ;在当前光标处以十六进制形式显示
   205                                                                              ;一个双字并推进光标
   206                                                                              ;输入：EDX=要转换并显示的数字
   207                                                                              ;输出：无
   208 000000FD 60                               pushad
   209 000000FE 1E                               push ds
   210                                  
   211 000000FF 66B83000                         mov ax,core_data_seg_sel           ;切换到核心数据段
   212 00000103 8ED8                             mov ds,ax
   213                                  
   214 00000105 BB[06050000]                     mov ebx,bin_hex                    ;指向核心数据段内的转换表
   215 0000010A B908000000                       mov ecx,8
   216                                    .xlt:
   217 0000010F C1C204                           rol edx,4
   218 00000112 89D0                             mov eax,edx
   219 00000114 83E00F                           and eax,0x0000000f
   220 00000117 D7                               xlat
   221                                  
   222 00000118 51                               push ecx
   223 00000119 88C1                             mov cl,al
   224 0000011B E8F1FEFFFF                       call put_char
   225 00000120 59                               pop ecx
   226                                  
   227 00000121 E2EC                             loop .xlt
   228                                  
   229 00000123 1F                               pop ds
   230 00000124 61                               popad
   231                                  
   232 00000125 CB                               retf
   233                                  
   234                                  ;-------------------------------------------------------------------------------
   235                                  allocate_memory:                            ;分配内存
   236                                                                              ;输入：ECX=希望分配的字节数
   237                                                                              ;输出：ECX=起始线性地址 
   238 00000126 1E                               push ds
   239 00000127 50                               push eax
   240 00000128 53                               push ebx
   241                                        
   242 00000129 B830000000                       mov eax,core_data_seg_sel
   243 0000012E 8ED8                             mov ds,eax
   244                                        
   245 00000130 A1[06000000]                     mov eax,[ram_alloc]
   246 00000135 01C8                             add eax,ecx                        ;下一次分配时的起始地址
   247                                        
   248                                           ;这里应当有检测可用内存数量的指令
   249                                            
   250 00000137 8B0D[06000000]                   mov ecx,[ram_alloc]                ;返回分配的起始地址
   251                                  
   252 0000013D 89C3                             mov ebx,eax
   253 0000013F 83E3FC                           and ebx,0xfffffffc
   254 00000142 83C304                           add ebx,4                          ;强制对齐 
   255 00000145 A903000000                       test eax,0x00000003                ;下次分配的起始地址最好是4字节对齐
   256 0000014A 0F45C3                           cmovnz eax,ebx                     ;如果没有对齐，则强制对齐 
   257 0000014D A3[06000000]                     mov [ram_alloc],eax                ;下次从该地址分配内存
   258                                                                              ;cmovcc指令可以避免控制转移 
   259 00000152 5B                               pop ebx
   260 00000153 58                               pop eax
   261 00000154 1F                               pop ds
   262                                  
   263 00000155 CB                               retf
   264                                  
   265                                  ;-------------------------------------------------------------------------------
   266                                  set_up_gdt_descriptor:                      ;在GDT内安装一个新的描述符
   267                                                                              ;输入：EDX:EAX=描述符 
   268                                                                              ;输出：CX=描述符的选择子
   269 00000156 50                               push eax
   270 00000157 53                               push ebx
   271 00000158 52                               push edx
   272                                        
   273 00000159 1E                               push ds
   274 0000015A 06                               push es
   275                                        
   276 0000015B BB30000000                       mov ebx,core_data_seg_sel          ;切换到核心数据段
   277 00000160 8EDB                             mov ds,ebx
   278                                  
   279 00000162 0F0105[00000000]                 sgdt [pgdt]                        ;以便开始处理GDT
   280                                  
   281 00000169 BB08000000                       mov ebx,mem_0_4_gb_seg_sel
   282 0000016E 8EC3                             mov es,ebx
   283                                  
   284 00000170 0FB71D[00000000]                 movzx ebx,word [pgdt]              ;GDT界限 
   285 00000177 6643                             inc bx                             ;GDT总字节数，也是下一个描述符偏移 
   286 00000179 031D[02000000]                   add ebx,[pgdt+2]                   ;下一个描述符的线性地址 
   287                                        
   288 0000017F 268903                           mov [es:ebx],eax
   289 00000182 26895304                         mov [es:ebx+4],edx
   290                                        
   291 00000186 668305[00000000]08               add word [pgdt],8                  ;增加一个描述符的大小   
   292                                        
   293 0000018E 0F0115[00000000]                 lgdt [pgdt]                        ;对GDT的更改生效 
   294                                         
   295 00000195 66A1[00000000]                   mov ax,[pgdt]                      ;得到GDT界限值
   296 0000019B 6631D2                           xor dx,dx
   297 0000019E 66BB0800                         mov bx,8
   298 000001A2 66F7F3                           div bx                             ;除以8，去掉余数
   299 000001A5 6689C1                           mov cx,ax                          
   300 000001A8 66C1E103                         shl cx,3                           ;将索引号移到正确位置 
   301                                  
   302 000001AC 07                               pop es
   303 000001AD 1F                               pop ds
   304                                  
   305 000001AE 5A                               pop edx
   306 000001AF 5B                               pop ebx
   307 000001B0 58                               pop eax
   308                                        
   309 000001B1 CB                               retf 
   310                                  ;-------------------------------------------------------------------------------
   311                                  make_seg_descriptor:                        ;构造存储器和系统的段描述符
   312                                                                              ;输入：EAX=线性基地址
   313                                                                              ;      EBX=段界限
   314                                                                              ;      ECX=属性。各属性位都在原始
   315                                                                              ;          位置，无关的位清零 
   316                                                                              ;返回：EDX:EAX=描述符
   317 000001B2 89C2                             mov edx,eax
   318 000001B4 C1E010                           shl eax,16
   319 000001B7 6609D8                           or ax,bx                           ;描述符前32位(EAX)构造完毕
   320                                  
   321 000001BA 81E20000FFFF                     and edx,0xffff0000                 ;清除基地址中无关的位
   322 000001C0 C1C208                           rol edx,8
   323 000001C3 0FCA                             bswap edx                          ;装配基址的31~24和23~16  (80486+)
   324                                  
   325 000001C5 6631DB                           xor bx,bx
   326 000001C8 09DA                             or edx,ebx                         ;装配段界限的高4位
   327                                  
   328 000001CA 09CA                             or edx,ecx                         ;装配属性
   329                                  
   330 000001CC CB                               retf
   331                                  
   332                                  ;===============================================================================
   333                                  SECTION core_data vstart=0                  ;系统核心的数据段
   334                                  ;-------------------------------------------------------------------------------
   335 00000000 0000                             pgdt             dw  0             ;用于设置和修改GDT 
   336 00000002 00000000                                          dd  0
   337                                  
   338 00000006 00001000                         ram_alloc        dd  0x00100000    ;下次分配内存时的起始地址
   339                                  
   340                                           ;符号地址检索表
   341                                           salt:
   342 0000000A 405072696E74537472-              salt_1           db  '@PrintString'
   342 00000013 696E67             
   343 00000016 00<rept>                                     times 256-($-salt_1) db 0
   344 0000010A [00000000]                                        dd  put_string
   345 0000010E 2800                                              dw  sys_routine_seg_sel
   346                                  
   347 00000110 40526561644469736B-              salt_2           db  '@ReadDiskData'
   347 00000119 44617461           
   348 0000011D 00<rept>                                     times 256-($-salt_2) db 0
   349 00000210 [B8000000]                                        dd  read_hard_disk_0
   350 00000214 2800                                              dw  sys_routine_seg_sel
   351                                  
   352 00000216 405072696E7444776F-              salt_3           db  '@PrintDwordAsHexString'
   352 0000021F 726441734865785374-
   352 00000228 72696E67           
   353 0000022C 00<rept>                                     times 256-($-salt_3) db 0
   354 00000316 [FD000000]                                        dd  put_hex_dword
   355 0000031A 2800                                              dw  sys_routine_seg_sel
   356                                  
   357 0000031C 405465726D696E6174-              salt_4           db  '@TerminateProgram'
   357 00000325 6550726F6772616D   
   358 0000032D 00<rept>                                     times 256-($-salt_4) db 0
   359 0000041C [0A020000]                                        dd  return_point
   360 00000420 3800                                              dw  core_code_seg_sel
   361                                  
   362                                           salt_item_len   equ $-salt_4
   363                                           salt_items      equ ($-salt)/salt_item_len
   364                                  
   365 00000422 2020496620796F7520-              message_1        db  '  If you seen this message,that means we '
   365 0000042B 7365656E2074686973-
   365 00000434 206D6573736167652C-
   365 0000043D 74686174206D65616E-
   365 00000446 7320776520         
   366 0000044B 617265206E6F772069-                               db  'are now in protect mode,and the system '
   366 00000454 6E2070726F74656374-
   366 0000045D 206D6F64652C616E64-
   366 00000466 207468652073797374-
   366 0000046F 656D20             
   367 00000472 636F7265206973206C-                               db  'core is loaded,and the video display '
   367 0000047B 6F616465642C616E64-
   367 00000484 207468652076696465-
   367 0000048D 6F20646973706C6179-
   367 00000496 20                 
   368 00000497 726F7574696E652077-                               db  'routine works perfectly.',0x0d,0x0a,0
   368 000004A0 6F726B732070657266-
   368 000004A9 6563746C792E0D0A00 
   369                                  
   370 000004B2 20204C6F6164696E67-              message_5        db  '  Loading user program...',0
   370 000004BB 20757365722070726F-
   370 000004C4 6772616D2E2E2E00   
   371                                           
   372 000004CC 446F6E652E0D0A00                 do_status        db  'Done.',0x0d,0x0a,0
   373                                           
   374 000004D4 0D0A0D0A0D0A                     message_6        db  0x0d,0x0a,0x0d,0x0a,0x0d,0x0a
   375 000004DA 202055736572207072-                               db  '  User program terminated,control returned.',0
   375 000004E3 6F6772616D20746572-
   375 000004EC 6D696E617465642C63-
   375 000004F5 6F6E74726F6C207265-
   375 000004FE 7475726E65642E00   
   376                                  
   377 00000506 303132333435363738-              bin_hex          db '0123456789ABCDEF'
   377 0000050F 39414243444546     
   378                                                                              ;put_hex_dword子过程用的查找表
   379 00000516 00<rept>                         core_buf   times 2048 db 0         ;内核用的缓冲区
   380                                  
   381 00000D16 00000000                         esp_pointer      dd 0              ;内核用来临时保存自己的栈指针     
   382                                  
   383 00000D1A 0D0A202000                       cpu_brnd0        db 0x0d,0x0a,'  ',0
   384 00000D1F 00<rept>                         cpu_brand  times 49 db 0
   385 00000D50 0D0A0D0A00                       cpu_brnd1        db 0x0d,0x0a,0x0d,0x0a,0
   386                                  
   387                                  ;===============================================================================
   388                                  SECTION core_code vstart=0
   389                                  ;-------------------------------------------------------------------------------
   390                                  load_relocate_program:                      ;加载并重定位用户程序
   391                                                                              ;输入：ESI=起始逻辑扇区号
   392                                                                              ;返回：AX=指向用户程序头部的选择子 
   393 00000000 53                               push ebx
   394 00000001 51                               push ecx
   395 00000002 52                               push edx
   396 00000003 56                               push esi
   397 00000004 57                               push edi
   398                                        
   399 00000005 1E                               push ds
   400 00000006 06                               push es
   401                                        
   402 00000007 B830000000                       mov eax,core_data_seg_sel
   403 0000000C 8ED8                             mov ds,eax                         ;切换DS到内核数据段
   404                                  
   405 0000000E 89F0                             mov eax,esi                        ;读取程序头部数据 
   406 00000010 BB[16050000]                     mov ebx,core_buf                        
   407 00000015 9A[B8000000]2800                 call sys_routine_seg_sel:read_hard_disk_0
   408                                  
   409                                           ;以下判断整个程序有多大
   410 0000001C A1[16050000]                     mov eax,[core_buf]                 ;程序尺寸
   411 00000021 89C3                             mov ebx,eax
   412 00000023 81E300FEFFFF                     and ebx,0xfffffe00                 ;使之512字节对齐（能被512整除的数， 
   413 00000029 81C300020000                     add ebx,512                        ;低9位都为0 
   414 0000002F A9FF010000                       test eax,0x000001ff                ;程序的大小正好是512的倍数吗? 
   415 00000034 0F45C3                           cmovnz eax,ebx                     ;不是。使用凑整的结果 
   416                                        
   417 00000037 89C1                             mov ecx,eax                        ;实际需要申请的内存数量
   418 00000039 9A[26010000]2800                 call sys_routine_seg_sel:allocate_memory
   419 00000040 89CB                             mov ebx,ecx                        ;ebx -> 申请到的内存首地址
   420 00000042 53                               push ebx                           ;保存该首地址 
   421 00000043 31D2                             xor edx,edx
   422 00000045 B900020000                       mov ecx,512
   423 0000004A F7F1                             div ecx
   424 0000004C 89C1                             mov ecx,eax                        ;总扇区数 
   425                                        
   426 0000004E B808000000                       mov eax,mem_0_4_gb_seg_sel         ;切换DS到0-4GB的段
   427 00000053 8ED8                             mov ds,eax
   428                                  
   429 00000055 89F0                             mov eax,esi                        ;起始扇区号 
   430                                    .b1:
   431 00000057 9A[B8000000]2800                 call sys_routine_seg_sel:read_hard_disk_0
   432 0000005E 40                               inc eax
   433 0000005F E2F6                             loop .b1                           ;循环读，直到读完整个用户程序
   434                                  
   435                                           ;建立程序头部段描述符
   436 00000061 5F                               pop edi                            ;恢复程序装载的首地址 
   437 00000062 89F8                             mov eax,edi                        ;程序头部起始线性地址
   438 00000064 8B5F04                           mov ebx,[edi+0x04]                 ;段长度
   439 00000067 4B                               dec ebx                            ;段界限 
   440 00000068 B900924000                       mov ecx,0x00409200                 ;字节粒度的数据段描述符
   441 0000006D 9A[B2010000]2800                 call sys_routine_seg_sel:make_seg_descriptor
   442 00000074 9A[56010000]2800                 call sys_routine_seg_sel:set_up_gdt_descriptor
   443 0000007B 66894F04                         mov [edi+0x04],cx                   
   444                                  
   445                                           ;建立程序代码段描述符
   446 0000007F 89F8                             mov eax,edi
   447 00000081 03470C                           add eax,[edi+0x0c]                 ;代码起始线性地址
   448 00000084 8B5F10                           mov ebx,[edi+0x10]                 ;段长度
   449 00000087 4B                               dec ebx                            ;段界限
   450 00000088 B900984000                       mov ecx,0x00409800                 ;字节粒度的代码段描述符
   451 0000008D 9A[B2010000]2800                 call sys_routine_seg_sel:make_seg_descriptor
   452 00000094 9A[56010000]2800                 call sys_routine_seg_sel:set_up_gdt_descriptor
   453 0000009B 66894F0C                         mov [edi+0x0c],cx
   454                                  
   455                                           ;建立程序数据段描述符
   456 0000009F 89F8                             mov eax,edi
   457 000000A1 034714                           add eax,[edi+0x14]                 ;数据段起始线性地址
   458 000000A4 8B5F18                           mov ebx,[edi+0x18]                 ;段长度
   459 000000A7 4B                               dec ebx                            ;段界限
   460 000000A8 B900924000                       mov ecx,0x00409200                 ;字节粒度的数据段描述符
   461 000000AD 9A[B2010000]2800                 call sys_routine_seg_sel:make_seg_descriptor
   462 000000B4 9A[56010000]2800                 call sys_routine_seg_sel:set_up_gdt_descriptor
   463 000000BB 66894F14                         mov [edi+0x14],cx
   464                                  
   465                                           ;建立程序堆栈段描述符
   466 000000BF 89F8                             mov eax,edi
   467 000000C1 03471C                           add eax,[edi+0x1c]                 ;数据段起始线性地址
   468 000000C4 8B5F20                           mov ebx,[edi+0x20]                 ;段长度
   469 000000C7 4B                               dec ebx                            ;段界限
   470 000000C8 B900924000                       mov ecx,0x00409200                 ;字节粒度的数据段描述符
   471 000000CD 9A[B2010000]2800                 call sys_routine_seg_sel:make_seg_descriptor
   472 000000D4 9A[56010000]2800                 call sys_routine_seg_sel:set_up_gdt_descriptor
   473 000000DB 66894F1C                         mov [edi+0x1c],cx
   474                                  
   475                                           ;重定位SALT
   476 000000DF 8B4704                           mov eax,[edi+0x04]
   477 000000E2 8EC0                             mov es,eax                         ;es -> 用户程序头部
   478 000000E4 B830000000                       mov eax,core_data_seg_sel
   479 000000E9 8ED8                             mov ds,eax
   480                                  
   481 000000EB FC                               cld
   482                                  
   483 000000EC 268B0D24000000                   mov ecx,[es:0x24]                  ;用户程序的SALT条目数
   484 000000F3 BF28000000                       mov edi,0x28                       ;用户程序内的SALT位于头部内0x2c处
   485                                    .b2:
   486 000000F8 51                               push ecx
   487 000000F9 57                               push edi
   488                                  
   489 000000FA B904000000                       mov ecx,salt_items
   490 000000FF BE[0A000000]                     mov esi,salt
   491                                    .b3:
   492 00000104 57                               push edi
   493 00000105 56                               push esi
   494 00000106 51                               push ecx
   495                                  
   496 00000107 B940000000                       mov ecx,64                         ;检索表中，每条目的比较次数
   497 0000010C F3A7                             repe cmpsd                         ;每次比较4字节
   498 0000010E 7515                             jnz .b4
   499 00000110 8B06                             mov eax,[esi]                      ;若匹配，esi恰好指向其后的地址数据
   500 00000112 26898700FFFFFF                   mov [es:edi-256],eax               ;将字符串改写成偏移地址
   501 00000119 668B4604                         mov ax,[esi+4]
   502 0000011D 2666898704FFFFFF                 mov [es:edi-252],ax                ;以及段选择子
   503                                    .b4:
   504                                  
   505 00000125 59                               pop ecx
   506 00000126 5E                               pop esi
   507 00000127 81C606010000                     add esi,salt_item_len
   508 0000012D 5F                               pop edi                            ;从头比较
   509 0000012E E2D4                             loop .b3
   510                                  
   511 00000130 5F                               pop edi
   512 00000131 81C700010000                     add edi,256
   513 00000137 59                               pop ecx
   514 00000138 E2BE                             loop .b2
   515                                  
   516 0000013A 2666A104000000                   mov ax,[es:0x04]
   517                                  
   518 00000141 07                               pop es                             ;恢复到调用此过程前的es段 
   519 00000142 1F                               pop ds                             ;恢复到调用此过程前的ds段
   520                                        
   521 00000143 5F                               pop edi
   522 00000144 5E                               pop esi
   523 00000145 5A                               pop edx
   524 00000146 59                               pop ecx
   525 00000147 5B                               pop ebx
   526                                        
   527 00000148 C3                               ret
   528                                        
   529                                  ;-------------------------------------------------------------------------------
   530                                  start:
   531 00000149 B930000000                       mov ecx,core_data_seg_sel           ;使ds指向核心数据段 
   532 0000014E 8ED9                             mov ds,ecx
   533                                  
   534 00000150 BB[22040000]                     mov ebx,message_1
   535 00000155 9A[00000000]2800                 call sys_routine_seg_sel:put_string
   536                                                                           
   537                                           ;显示处理器品牌信息 
   538 0000015C B802000080                       mov eax,0x80000002
   539 00000161 0FA2                             cpuid
   540 00000163 A3[1F0D0000]                     mov [cpu_brand + 0x00],eax
   541 00000168 891D[230D0000]                   mov [cpu_brand + 0x04],ebx
   542 0000016E 890D[270D0000]                   mov [cpu_brand + 0x08],ecx
   543 00000174 8915[2B0D0000]                   mov [cpu_brand + 0x0c],edx
   544                                        
   545 0000017A B803000080                       mov eax,0x80000003
   546 0000017F 0FA2                             cpuid
   547 00000181 A3[2F0D0000]                     mov [cpu_brand + 0x10],eax
   548 00000186 891D[330D0000]                   mov [cpu_brand + 0x14],ebx
   549 0000018C 890D[370D0000]                   mov [cpu_brand + 0x18],ecx
   550 00000192 8915[3B0D0000]                   mov [cpu_brand + 0x1c],edx
   551                                  
   552 00000198 B804000080                       mov eax,0x80000004
   553 0000019D 0FA2                             cpuid
   554 0000019F A3[3F0D0000]                     mov [cpu_brand + 0x20],eax
   555 000001A4 891D[430D0000]                   mov [cpu_brand + 0x24],ebx
   556 000001AA 890D[470D0000]                   mov [cpu_brand + 0x28],ecx
   557 000001B0 8915[4B0D0000]                   mov [cpu_brand + 0x2c],edx
   558                                  
   559 000001B6 BB[1A0D0000]                     mov ebx,cpu_brnd0
   560 000001BB 9A[00000000]2800                 call sys_routine_seg_sel:put_string
   561 000001C2 BB[1F0D0000]                     mov ebx,cpu_brand
   562 000001C7 9A[00000000]2800                 call sys_routine_seg_sel:put_string
   563 000001CE BB[500D0000]                     mov ebx,cpu_brnd1
   564 000001D3 9A[00000000]2800                 call sys_routine_seg_sel:put_string
   565                                  
   566 000001DA BB[B2040000]                     mov ebx,message_5
   567 000001DF 9A[00000000]2800                 call sys_routine_seg_sel:put_string
   568 000001E6 BE32000000                       mov esi,50                          ;用户程序位于逻辑50扇区 
   569 000001EB E810FEFFFF                       call load_relocate_program
   570                                        
   571 000001F0 BB[CC040000]                     mov ebx,do_status
   572 000001F5 9A[00000000]2800                 call sys_routine_seg_sel:put_string
   573                                        
   574 000001FC 8925[160D0000]                   mov [esp_pointer],esp               ;临时保存堆栈指针
   575                                         
   576 00000202 8ED8                             mov ds,ax
   577                                  
   578 00000204 FF2D08000000                     jmp far [0x08]                      ;控制权交给用户程序（入口点）
   579                                                                               ;堆栈可能切换 
   580                                  
   581                                  return_point:                                ;用户程序返回点
   582 0000020A B830000000                       mov eax,core_data_seg_sel           ;使ds指向核心数据段
   583 0000020F 8ED8                             mov ds,eax
   584                                  
   585 00000211 B818000000                       mov eax,core_stack_seg_sel          ;切换回内核自己的堆栈
   586 00000216 8ED0                             mov ss,eax 
   587 00000218 8B25[160D0000]                   mov esp,[esp_pointer]
   588                                  
   589 0000021E BB[D4040000]                     mov ebx,message_6
   590 00000223 9A[00000000]2800                 call sys_routine_seg_sel:put_string
   591                                  
   592                                           ;这里可以放置清除用户程序各种描述符的指令
   593                                           ;也可以加载并启动其它程序
   594                                         
   595 0000022A F4                               hlt
   596                                              
   597                                  ;===============================================================================
   598                                  SECTION core_trail
   599                                  ;-------------------------------------------------------------------------------
   600                                  core_end:
